/*
SQLyog Ultimate v13.1.1 (64 bit)
MySQL - 10.4.12-MariaDB-log : Database - vblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`vblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `vblog`;

/*Table structure for table `tb_article` */

DROP TABLE IF EXISTS `tb_article`;

CREATE TABLE `tb_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `channel_id` int(11) NOT NULL COMMENT '栏目id',
  `title` varchar(100) DEFAULT NULL COMMENT '标题',
  `title_img` varchar(100) DEFAULT NULL COMMENT '标题图',
  `summary` text DEFAULT NULL COMMENT '摘要',
  `url` varchar(100) DEFAULT NULL COMMENT '外链URL',
  `content` mediumtext DEFAULT NULL COMMENT '正文',
  `status` int(1) DEFAULT NULL COMMENT '0待发布1发布',
  `comment_status` int(1) DEFAULT NULL COMMENT '0/Null允许评论，不允许评论',
  `rotation` int(1) DEFAULT NULL COMMENT '0/NULL非轮播 1 轮播',
  `top` int(1) DEFAULT NULL COMMENT '0/null不置顶，1置顶',
  `orderby` int(11) DEFAULT NULL COMMENT '排序',
  `create_date` date DEFAULT NULL COMMENT '创建时间',
  `create_user` int(11) DEFAULT NULL COMMENT '创建人',
  `update_date` date DEFAULT NULL,
  `article_view` int(11) DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `id_articleId_id` (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=85 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='文章';

/*Data for the table `tb_article` */

insert  into `tb_article`(`id`,`channel_id`,`title`,`title_img`,`summary`,`url`,`content`,`status`,`comment_status`,`rotation`,`top`,`orderby`,`create_date`,`create_user`,`update_date`,`article_view`) values 
(60,24,'Websocket通信原理','http://8.135.100.252/image/2019-10-1/75b6d879-deef-4997-9b2a-9f1eacd13665.jpg','Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。','','\n\n\n\n# Redis\n\n\n\n## Nosql概述\n\n大数据时代；\n\n大数据一般数据库无法进行分析处理了。\n\n压力越来越大，适者生存！一定要逼着自己学习，这是在这个社会生存的唯一法则！\n\n#### 为什么要使用Nosql?\n\n> 1、单击Mysql的年代\n\n1. 数据量如果太大，一个机器放不下\n2. 数据的索引（B+Tree），一个机器也放不下\n3. 访问量（读写混合），一个服务区承受不了\n\n只要你出现以上的三种情况之一，那么你就必须要晋级\n\n\n\n> Memcached(缓存)+Mysql+垂直拆分\n\n网站80%的情况都是在读，每次都要去查询的话就十分麻烦!所以说我们越希望减轻数据的压力，我们可以使用缓存来保证效率\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105091800653.png\" alt=\"image-20201105091800653\" style=\"zoom:50%;\" />\n\n\n\n> 分库分表+水平拆分+\n\n技术1和业务在发展的同时，对人的要求也越来越高\n\n==本质：数据库（读，写）==\n\n早些年MylSAM:表锁,十分影响效率！高并发下就会出现严重的锁问题\n\n转战Innodb: 行锁\n\n慢慢的就开始使用分库分表来解决写的压力\n\nMysql的集群\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105092719168.png\" alt=\"image-20201105092719168\" style=\"zoom: 67%;\" />\n\n\n\n> 如今最近年代\n\n2010---2020十年之间，世界已经发生了翻天覆地的变化。\n\nMysql 等关型数据库就不够用了！数据量很多，变化很大！\n\n> 目前一个基本的互联网样子		\n\n\n\n![image-20201105094508658](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105094508658.png)\n\n> 为什么要用NoSQL！\n\n用户的信息，社交网络、地理位置。用户自己产生的数据用户日志等等爆发式增长。\n\n这时候我们就需要使用NoSql数据库的，Nosql可以很好的处理以上的情况。\n\n\n\n#### 什么是NoSQL\n\n> NoSQL\n\n(不仅仅是SQL)\n\n关系型数据库：表格，行，列\n\n泛指非关系型数据库，随着web2.0互联网的诞生！传统的关系型数据库，很难对付web2.0时代！尤其是超大规模的高并发的社区！暴露出很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，\n\n> NoSQl\n\n1. 方便扩展（数据之间没有关系，很好扩展）\n2. 大数据量高性能（Redis 一秒可以写8万次，读取11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能比较高）\n3. 数据库类型是多样型的！（不需要设计数据库，随去随用！如果是数据库量十分大的表，很多人就无法设计了！）\n4. 传统的RDBMS和NOSQL\n\n```\n传统的RDBMS\n- 结构化组织\n- SQL\n- 数据和关系都存在单独的表中\n- 操作，数据定义语言\n- 基础的事务\n```\n\n```\nnosql\n- 不仅仅是数据\n- 没有固定的查询语言\n键值对存储，列存储，文档存储，图形数据库（社交关系）\n- 最终一致性\n- CAP定理和BASE（异地多活）\n- 高性能，高可用，高可扩展\n```\n\n> 了解：3V+3高\n\n大数据时代的3V:主要描述问题的\n\n1. 海量Volume\n2. 多样Variety\n3. 实时Velocity\n\n大数据时代的3高：主要是对程序的要求\n\n1. 高并发\n2. 高可扩\n3. 高性能\n\n真正在公司中的时间 ：NoSQL+RDBMS 一起使用才是最强的\n\n技术没有高低之分，就看你如何去使用！（提升内功，思维的提高！）\n\n#### 阿里巴演进分析\n\n\n\n```bash\n#1、商品的基本信息\n名称、价格、商家信息；\n关系性数据库就可以解决了! /Oracle/ mysql （淘宝早年就去IOE了-王坚 ：推荐文章：阿里云的这群疯子：40分钟）\n	淘宝内部的Mysql 不是大家用的Mysql\n#2、 商品的描述 、评论（文字比较多）\n	文档数据库中，MongoDB\n	\n#3、 图片\n	分布式文件系统 FastDFS\n	-淘宝自己的 TFS\n	-Gooale的 GFS\n	-Hadoop 的 HDFS\n	-阿里云的OsS存储\n#4、商品的关键字	（搜索）\n	-搜索引擎 solr elasticsearch\n	-Iserach：多隆\n	所有牛逼的人都有一段苦逼的岁月！但是你只要想SB一样的坚持，终将牛逼\n	\n#5、商品热门的波段信息\n	-内存数据库\n	-Redis tair、Memache...\n	\n#6、商品的交易、外部的支付接口\n	-三方应用\n```\n\n要知道一个简单地网页背后的技术一定不是想的那么简单\n\n大型互联网应用问题\n\n- 数据类型太多了\n- 数据源繁多。经常重构！\n- 数据要改造，大面积改造\n\n\n\n#### NoSQL的四大分类\n\n**KV键值对**：\n\n- 新浪：**Redis**\n- 美团:Redis+Tair\n- 阿里、百度：Redis+Menmecache\n\n**文档型数据库（bson和json）**：\n\n- **MongoDB**（一般必须要掌握）\n  - MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档\n  - MongoDB是一个介于关系型数据库和非关系型数据中中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库的！\n- ConthDB\n\n**列存储数据库**\n\n- **HBase**\n- 分布式文件系统\n\n**图关系数据库**\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105130753396.png\" alt=\"image-20201105130753396\" style=\"zoom:67%;\" />\n\n- 他不是存图形的，放的是关系，比如朋友圈社交网络，广告推荐\n- **Neo4j**\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105131101775.png\" alt=\"image-20201105131101775\" style=\"zoom:67%;\" />\n\n敬畏之心可以使人进步！\n\n\n\n## Redis\n\n### 概述\n\n> Redis是什么？\n\n==Redis（Remote Dictionary Server )，即远程字典服务！==\n\n是一个开源的使用ANSI [C语言](https://baike.baidu.com/item/C语言)编写、支持网络、可基于内存亦可持久化的日志型、Key-Value[数据库](https://baike.baidu.com/item/数据库/103728)，并提供多种语言的API\n\n区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。\n\n> Redis能干嘛？\n\n1. 内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof）\n2. 效率高，可以用于高速缓存\n3. 发布订阅系统\n4. 地图信息分析\n5. 计时器、计数器（浏览量）\n6. ......\n\n> 特性\n\n1. 多样的数据类型\n2. 持久化\n3. 集群\n4. 事务\n5. .....\n\n\n\n> 学习中需要用到的东西\n\n1. 狂神公众号：狂神说\n\n2. 官网：https://redis.io/\n\n3. 中文网：https://redis.cn/\n\n4. 下载地址，官方下载即可\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105132940425.png\" alt=\"image-20201105132940425\" style=\"zoom:50%;\" />\n\n   注意：windows在github上下载，（停更很久了！）\n\n\n\n### Windows安装\n\n1. 下载安装包\n\n2. 下载完毕得到压缩包\n\n3. 解压到自己电脑的环境目录下的就可以了\n\n   ![image-20201105142733690](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105142733690.png)\n\n4. 开启Redis 双击运行服务即可\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105142846757.png\" alt=\"image-20201105142846757\" style=\"zoom: 50%;\" />\n\n5. 使用redis客户端来连接redis\n\n   **<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105143140662.png\" alt=\"image-20201105143140662\" style=\"zoom:50%;\" />**\n\n6. \n\n\n\n### Linux安装\n\n1. 下载安装包！`redis-6.0.9.tar.gz`\n\n2. 解压Redis安装包！程序放在Opt目录下\n\n   解压命令：tar -zxvf 压缩包\n\n   ![image-20201105145458201](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105145458201.png)\n\n3. 进入解压后的文件可以看到redis的配置文件\n\n   ![image-20201105145708186](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105145708186.png)\n\n4. 环境安装\n\n   ```bash\n   yum install gcc-c++\n   \n   make\n   make install PREFIX=/usr/local/redis  安装到一个自定义的文件夹\n   ```\n\n5. 安装完路径在 `usr/local/redis/bin `\n\n   ![image-20201105163747347](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105163747347.png)\n\n6. redis 默认不是后台启动的，修改配置文件！，改为yes\n\n   ![image-20201105164219211](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105164219211.png)\n\n7. 启动redis服务！\n\n   ![image-20201105170730678](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105170730678.png)\n\n8. 使用redis-cli进行测试连接\n\n   ![image-20201105171050884](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171050884.png)\n\n9. 查看redis的进程是否开启\n\n   ![image-20201105171342657](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171342657.png)\n\n10. 如何关闭redis服务呢？`shutdown`\n\n    ![image-20201105171524129](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171524129.png)\n\n11. 再次查看进程是否存在\n\n    ![image-20201105171617419](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105171617419.png)\n\n12. 后面我们会使用单机多Redis启动集群测试！\n\n\n\n### 测试性能\n\n**redis-benchmarks**是一个压力测试工具\n\n官方自带的性能测试工具！\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105191058824.png\" alt=\"image-20201105191058824\" style=\"zoom: 80%;\" />\n\n\n\n我们来测试一下\n\n```bash\n#测试 100个并发连接 100000个请求\nredis-benchmark -h localhost -p 6379 -c 100 -n 100000\n```\n\n![image-20201105191906373](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105191906373.png\n\n![image-20201105192120889](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201105192120889.png)\n\n\n\n\n\n### 基础知识\n\nredis默认有16个数据库\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201106084716251.png\" alt=\"image-20201106084716251\" style=\"zoom:67%;\" />\n\n默认使用的是第0个\n\n可以使用select进行切换\n\n```bash\n127.0.0.1:6379> select 3  #切换数据库\nOK\n127.0.0.1:6379[3]> DBSIZE 	#查看DB大小\n(integer) 0\n127.0.0.1:6379[3]> \n\n```\n\n```bash\n127.0.0.1:6379[3]> keys *   #查看所有的key\n1) \"name\"\n127.0.0.1:6379[3]> \n```\n\n清楚当前数据库内容`flushdb`\n\n```bash\n127.0.0.1:6379[3]> flushdb		#清除当前数据库\nOK\n127.0.0.1:6379[3]> keys *\n(empty list or set)\n127.0.0.1:6379[3]> \n```\n\n清除全部数据库的内容`FLUSHALL`\n\n\n\n\n\n> Redis是单线程的\n\n明白Redis是很快的，官方表示，Redis是基于内存操作的，CPU不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就是用单线程了！\n\nRedis是C语言写的，官方提供的数据为100000+QPS，完全不比是使用的key-value的Memecache差\n\nRedis为什么还这么快？\n\n1. 误区1：高性能的服务器一定是多线程的？\n2. 误区2：多线程（CPU上下文切换）一定比单线程效率高\n\n核心：redis是将所有的数据全部放在内存中的，所有说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，没有上下文切换效率就是最该的！多次读写都是在一个cpu上的，在内存情况下，这个就是最佳的方案\n\n## 五大数据类型\n\n\n\n\n\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作==数据库、缓存和消息中间件==。 它支持多种类型的数据结构，如 [字符串（strings）](http://redis.cn/topics/data-types-intro.html#strings)， [散列（hashes）](http://redis.cn/topics/data-types-intro.html#hashes)， [列表（lists）](http://redis.cn/topics/data-types-intro.html#lists)， [集合（sets）](http://redis.cn/topics/data-types-intro.html#sets)， [有序集合（sorted sets）](http://redis.cn/topics/data-types-intro.html#sorted-sets) 与范围查询， [bitmaps](http://redis.cn/topics/data-types-intro.html#bitmaps)， [hyperloglogs](http://redis.cn/topics/data-types-intro.html#hyperloglogs) 和 [地理空间（geospatial）](http://redis.cn/commands/geoadd.html) 索引半径查询。 Redis 内置了 [复制（replication）](http://redis.cn/topics/replication.html)，[LUA脚本（Lua scripting）](http://redis.cn/commands/eval.html)， [LRU驱动事件（LRU eviction）](http://redis.cn/topics/lru-cache.html)，[事务（transactions）](http://redis.cn/topics/transactions.html) 和不同级别的 [磁盘持久化（persistence）](http://redis.cn/topics/persistence.html)， 并通过 [Redis哨兵（Sentinel）](http://redis.cn/topics/sentinel.html)和自动 [分区（Cluster）](http://redis.cn/topics/cluster-tutorial.html)提供高可用性（high availability）。\n\n\n\n#### Redis-Key\n\n```bash\n127.0.0.1:6379> keys *    #查看所有的key \n1) \"name\"\n127.0.0.1:6379> set shunshun 1  #set key \nOK\n127.0.0.1:6379> keys *\n1) \"name\"\n2) \"shunshun\"\n127.0.0.1:6379> EXISTS name 	#判断当前的key 是否存在\n(integer) 1\n127.0.0.1:6379> move name 1		#移除当前的key \n(integer) 1\n127.0.0.1:6379> keys *\n1) \"shunshun\"\n127.0.0.1:6379> set name guoshun\nOK\n127.0.0.1:6379> keys *\n1) \"name\"\n2) \"shunshun\"\n127.0.0.1:6379> clear\n127.0.0.1:6379> keys *\n(empty list or set)\n127.0.0.1:6379> clear\n127.0.0.1:6379> keys *\n1) \"name\"\n2) \"shunshun\"\n127.0.0.1:6379> get name\n\"guoshun\"\n127.0.0.1:6379> EXPIRE name 10  #设置key的过期时间  单位是秒 \n(integer) 1\n127.0.0.1:6379> ttl name		#查看当前key的剩余时间\n(integer) -2\n127.0.0.1:6379> get name\n(nil)\n1) \"shunshun\" \n127.0.0.1:6379> type shunshun 		#查看当前key 的类型\nstring\n127.0.0.1:6379> \n\n```\n\n\n\n#### String（字符串）\n\n```bash\n################################################### #################################################\n127.0.0.1:6379> set key1 v1 			#设置值\nOK\n127.0.0.1:6379> EXISTS key1				#判断某一个Key是否存在\n(integer) 1\n127.0.0.1:6379> APPEND key1 \"hello\"		#追加字符串，如果当前key不存在，就相当与setkey\n(integer) 7\n127.0.0.1:6379> get key1			#获得值\n\"v1hello\"\n127.0.0.1:6379> STRLEN key1         #获取字符串的长度\n(integer) 7\n127.0.0.1:6379> APPEND key1 \",loveguohun\"\n(integer) 18\n127.0.0.1:6379> \n#####################################################################################################\n#i++\n#步长\n127.0.0.1:6379> get views			初始浏览量为0\n\"0\"\n127.0.0.1:6379> incr views 			#自增1\n(integer) 1\n127.0.0.1:6379> incr views\n(integer) 2\n127.0.0.1:6379> get views\n\"2\"\n127.0.0.1:6379> decr views			#自减1 浏览量减一\n(integer) 1\n127.0.0.1:6379> decr views\n(integer) 0\n127.0.0.1:6379> get views\n\"0\"\n127.0.0.1:6379> INCRBY view 10  	#可以设置步长，指定浏览量！\n(integer) 10\n127.0.0.1:6379> DECRBY view 5  		\n(integer) 5\n127.0.0.1:6379> \n#####################################################################################################\n#字符串范围 range\n127.0.0.1:6379> set key1 \"hello,zhaoguoshun\"	#设置key1 的值\nOK\n127.0.0.1:6379> get key1\n\"hello,zhaoguoshun\"\n127.0.0.1:6379> GETRANGE key1 0 3				#截取字符串 【0，3】\n\"hell\"\n127.0.0.1:6379> GETRANGE key1 0 -1				#获取全部的字符串，和get key是一样的\n\"hello,zhaoguoshun\"\n127.0.0.1:6379> \n\n#替换\n127.0.0.1:6379> set key2 abcde\nOK\n127.0.0.1:6379> get key2\n\"abcdefg\"\n127.0.0.1:6379> SETRANGE key2 1 xx    #替换指定位置开始的字符串！\n(integer) 7\n127.0.0.1:6379> get key2\n\"axxdefg\"\n127.0.0.1:6379> \n\n#####################################################################################################\n#setex (set with expire) #设置过期时间\n#setnx	(set if not exist)#不存在设置  （在分布式锁中会常常使用!）\n127.0.0.1:6379> setex key3 30 \"hello\"		#设置key3 的值为hello。30秒后过期\nOK\n127.0.0.1:6379> ttl keys\n(integer) -2\n127.0.0.1:6379> ttl key3\n(integer) 19\n127.0.0.1:6379> get key3\n\"hello\"\n127.0.0.1:6379> setnx mykey \"redis\"			#如果mykey 不存在创建redis\n(integer) 1\n127.0.0.1:6379> keys *\n1) \"mykey\"\n2) \"key2\"\n3) \"key1\"\n127.0.0.1:6379> setnx mykey \"MongeDB\"		#如果mykey存在，就创建失败\n(integer) 0\n127.0.0.1:6379> \n\n#####################################################################################################mse\nmset \nmget\n127.0.0.1:6379> mset k1 v1 ke1 v2 k2 v3 k3 			#同时设置多个值\n(error) ERR wrong number of arguments for MSET\n127.0.0.1:6379> mset k1 v1 k2 v2 k3 v3\nOK\n127.0.0.1:6379> keys *\n1) \"k3\"\n2) \"k2\"\n3) \"k1\"\n127.0.0.1:6379> mget k1 k2 k3  						#同时获取多个值\n1) \"v1\"\n2) \"v2\"\n3) \"v3\"\n127.0.0.1:6379> msetnx k1 v1 k4 v4					#msetnx  是一个原子性的操作，要么一起成功要么一起失败！\n(integer) 0\n127.0.0.1:6379> get key4\n(nil)\n127.0.0.1:6379> \n\n#对象\n\nset user :1 {name :guoshun,age 3} 		#设置user：对象，值为json字符串来保存一个对象\n#这里的key是一个巧妙的设计：user：{id}:{filed} ,在redis中是完全ok的\n127.0.0.1:6379> mset user:1:name guohun user:1:age 2\n127.0.0.1:6379> mset user:1:name:guoshun user:1:age 2\n(error) ERR wrong number of arguments for MSET\n127.0.0.1:6379> mget user:1:name user:1:age\n1) \"guohun\"\n2) \"2\"\n127.0.0.1:6379> \n\n#######################################################################################################\ngetset #先get 在set \n\n127.0.0.1:6379> getset db redis			#如果不存在值，则返回null\n(nil)\n127.0.0.1:6379> get db		\n\"redis\"\n127.0.0.1:6379> getset db mongdb		#如果存在值，获取原来的值，并设置新的值\n\"redis\"\n127.0.0.1:6379> get db\n\"mongdb\"\n127.0.0.1:6379> \n\n```\n\n数据结构是相同的！\n\nString类型的使用类型：value除了是我们我都字符串还可以是我们的数字！\n\n- 计数器\n- 统计多单位的数量 uid \n- 粉丝数az\n- 对象缓存存储\n\n\n\n\n\n\n\n#### List（列表）\n\n基本的数据类型，列表\n\n在Redis里面，我们可以把list玩成，栈，队列，阻塞队列！\n\n所有的list命令都是l开头的\n\n```bash\n################################################################################################################\n127.0.0.1:6379> LPUSH list one					#将一个值，或多个值插入到列表头部 （左）\n(integer) 1\n127.0.0.1:6379> Lpush list two \n(integer) 2\n127.0.0.1:6379> Lpush list three\n(integer) 3\n127.0.0.1:6379> Lrange list 0 -1\n1) \"three\"\n2) \"two\"\n3) \"one\"\n127.0.0.1:6379> lrange - 1\n1) \"three\"\n2) \"two\"\n127.0.0.1:6379> \n\n127.0.0.1:6379> rpush list right				#将一个值或多个值，查到列表尾部（右）\n(integer) 4\n127.0.0.1:6379> lrange list 0 -1				#获取list中值\n1) \"three\"\n2) \"two\"\n3) \"one\"\n4) \"right\"\n127.0.0.1:6379> \n################################################################################################################\nLPOP\nRPOP\n\n127.0.0.1:6379> Lpop list 				#移除list 的第一个元素\n\"two\"\n127.0.0.1:6379> Rpop list\n\"right\"\n127.0.0.1:6379> lrange list 0 -1		#移除list的最后一个元素\n1) \"one\"\n127.0.0.1:6379> \n################################################################################################################\nLindex\n127.0.0.1:6379> clear\n127.0.0.1:6379> lindex list 0 	#通过下标获得list中的某一个值\n\"one\"\n127.0.0.1:6379> \n\n################################################################################################################\nLlen\n 127.0.0.1:6379> Lpush list one\n(integer) 1\n127.0.0.1:6379> lpush list two\n(integer) 2\n127.0.0.1:6379> \n127.0.0.1:6379> lpush list three\n(integer) 3\n127.0.0.1:6379> Llen list			返回列表的长度\n(integer) 3\n127.0.0.1:6379> \n################################################################################################################\n移除指定的值！\n取关 uid\nlrem  \n\n127.0.0.1:6379> lrange list 0 -1 \n1) \"three\"\n2) \"three\"\n3) \"two\"\n4) \"one\"\n127.0.0.1:6379> lrem list 1 one   					#移除list 中一个value ，精确匹配\n(integer) 1\n127.0.0.1:6379> lrange list 0 -1\n1) \"three\"\n2) \"three\"\n3) \"two\"\n127.0.0.1:6379> \n################################################################################################################\n\ntrim 修剪  ： list 截断\n127.0.0.1:6379> rpush mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> rpush mylist \"hello1\"\n(integer) 2\n127.0.0.1:6379> rpush mylist \"hello2\"\n(integer) 3\n127.0.0.1:6379> rpush mylist \"hello3\"\n(integer) 4\n127.0.0.1:6379> ltrim mylist 1 2					#通过下标截取指定的长度，这个list已经被改变了，截取了只剩下截取的元素！\nOK\n127.0.0.1:6379> lrange mylist 0 -1\n1) \"hello1\"\n2) \"hello2\"\n127.0.0.1:6379> \n################################################################################################################\nlroplpush  #移除列表的最后一个元素，将它移动到新的列表中\n\n127.0.0.1:6379> rpush mylist \"hello\"\n(integer) 1\n127.0.0.1:6379> rpush mylist \"hello1\"\n(integer) 2\n127.0.0.1:6379> rpush mylist \"hello12\"\n(integer) 3\n127.0.0.1:6379> rpoplpush mylist myotherlist 		#移除列表的最后一个元素，将它移动到新的列表中\n\"hello12\"\n127.0.0.1:6379> lrange mylist 0 -1					#查看原来的表\n1) \"hello\"\n2) \"hello1\"\n127.0.0.1:6379> lrange myotherlist 0 -1				#查看目标列表中。确实存在该值\n1) \"hello12\"\n127.0.0.1:6379> \n\n################################################################################################################\nlset 将列表中指定下标的值替换为另一个值，更新操作\n127.0.0.1:6379> Exists list				#判断这一个列表是否存在\n(integer) 0\n127.0.0.1:6379> lset list 0 item		#如果不存在列表我们去更新就会报错\n(error) ERR no such key\n127.0.0.1:6379> lpush list value1\n(integer) 1\n127.0.0.1:6379> lrange list 0 0\n1) \"value1\"\n127.0.0.1:6379> lset list 0 item 		#如果存在，更新当前下标的值\nOK\n127.0.0.1:6379> lrange list 0 0		\n1) \"item\"	\n127.0.0.1:6379> 						#如果不存在，就会报错\n################################################################################################################\nlinsert #将某一个具体的value 插入到列表中，某个元素的前面或者后面\n\n127.0.0.1:6379> Rpush mylist hello\n(integer) 1\n127.0.0.1:6379> Rpush mylist word\n(integer) 2\n127.0.0.1:6379> Linsert mylist before \"word\" \"other\"\n(integer) 3\n127.0.0.1:6379> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"other\"\n3) \"word\"\n127.0.0.1:6379> linsert mylist after word new \n(integer) 4\n127.0.0.1:6379> LRANGE mylist 0 -1\n1) \"hello\"\n2) \"other\"\n3) \"word\"\n4) \"new\"\n127.0.0.1:6379> \n\n```\n\n> 小结\n\n- 实际上是一个链表，before Node after ，left，right都可以插入值\n- 如果key 不存在，创建新的链表\n- 如果key 存在，新增内容\n- 如果移除了所有的值，空链表，也代表不存在！\n- 再两边插入或者改动值效率最高！中间元素，相对来水效率会低一点点\n\n消息排队！消息队列 Lpush Rpop 栈（Lpush ,Lpop）\n\n\n\n#### Set(集合)\n\nset中的值是不能重复的！\n\n```bash\n################################################################################################################\n\n127.0.0.1:6379> sadd myset \"hello\"					#set集合中添加元素\n(integer) 1\n127.0.0.1:6379> sadd myset \"guoshun\"				\n(integer) 1\n127.0.0.1:6379> sadd myset \"love guoshun\"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset						#查看指定set的所有值\n1) \"love guoshun\"\n2) \"guoshun\"\n3) \"hello\"\n127.0.0.1:6379> sismember mylist hello				#判断某一个值存不存在\n(integer) 0\n127.0.0.1:6379> sismember myset  hello\n(integer) 1\n127.0.0.1:6379> sismember myset word\n(integer) 0\n127.0.0.1:6379> \n################################################################################################################\n127.0.0.1:6379> scard myset 				#获取set集合中的内容元素个数！\n(integer) 3\n127.0.0.1:6379> \n################################################################################################################\nsrem \n127.0.0.1:6379> srem myset \"hello\"				#移除set集合中的指定元素\n(integer) \n127.0.0.1:6379> scard myset \n(integer) 2\n127.0.0.1:6379> SMEMBERS myset\n1) \"love guoshun\"\n2) \"guoshun\"\n127.0.0.1:6379> \n################################################################################################################\nset无序不重复集合\n\n127.0.0.1:6379> SMEMBERS myset			随机抽选出一个元素\n1) \"love guoshun\"\n2) \"guoshun\"\n127.0.0.1:6379> SRandmeMber myset\n\"love guoshun\"\n127.0.0.1:6379> SRandmeMber myset\n\"love guoshun\"\n127.0.0.1:6379> SRandmeMber myset\n\"guoshun\"\n127.0.0.1:6379> \n################################################################################################################\n删除指定的key，随机删除key ！\n127.0.0.1:6379> SMEMBERS myset\n1) \"love guoshun\"\n2) \"guoshun\"\n127.0.0.1:6379> spop myset					#随机移除元素\n\"guoshun\"\n127.0.0.1:6379> spop myset \n\"love guoshun\"\n127.0.0.1:6379> SMEMBERS myset\n(empty list or set)\n127.0.0.1:6379> \n################################################################################################################\n将一个指定的值，移动到另外一个set集合中\n\n127.0.0.1:6379> sadd myset \"hello\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"hello1\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"hello12\"\n(integer) 1\n127.0.0.1:6379> sadd myset \"set2\"\n(integer) 1\n127.0.0.1:6379> smove myset myset2 \"hello\"\n(integer) 1\n127.0.0.1:6379> SMEMBERS myset\n1) \"hello12\"\n2) \"set2\"\n3) \"hello1\"\n127.0.0.1:6379> SMEMBERS myset2\n1) \"hello\"\n127.0.0.1:6379> \n################################################################################################################\n微博 b站 共同关注（并集）\n数字集合类 \n	-差集\n	-交集\n	-并集\n127.0.0.1:6379> sadd key1 a\n(integer) 1\n127.0.0.1:6379> sadd key1 b\n(integer) 1\n127.0.0.1:6379> sadd key1 c\n(integer) 1\n127.0.0.1:6379> sadd key1 d\n(integer) 1\n127.0.0.1:6379> sadd key2 c\n(integer) 1\n127.0.0.1:6379> sadd key2 d\n(integer) 1\n127.0.0.1:6379> sadd key2 e\n(integer) 1\n127.0.0.1:6379> sdiff key key2 					#差集\n(empty list or set)\n127.0.0.1:6379> sdiff key1 key2 				\n1) \"b\"\n2) \"a\"\n127.0.0.1:6379> sdiff key2 key1\n1) \"e\"\n127.0.0.1:6379> sinter key1 key2				#交集\n1) \"d\"\n2) \"c\"\n127.0.0.1:6379> sunion key1 key2				#并集\n1) \"a\"\n2) \"c\"\n3) \"d\"\n4) \"b\"\n5) \"e\"\n127.0.0.1:6379>\n\n```\n\n微博，A用户将所有关注的人放在一个set集合中！将粉丝也放在一个集合中\n\n\n\n\n\n#### Hash(哈希)\n\n\n\nMap 集合，key-<key,vlaue>时候这个值是一个Map集合!本质和String类型没有太大区别\n\nhset myhash field guoshun\n\n\n\n```bash\n127.0.0.1:6379> hset myhash field guoshun					#set一个具体 key-value\n(integer) 1\n127.0.0.1:6379> hget myhash field							#获取一个字段值\n\"guoshun\"\n127.0.0.1:6379> hmset myhash field hello field2 world		#set 多个key-value\nOK\n127.0.0.1:6379> keys *\n1) \"key2\"\n2) \"key\"\n3) \"myhash\"\n127.0.0.1:6379> hget myhash field \n\"hello\"\n127.0.0.1:6379> hmget myhash field field2					#获取多个字段值\n1) \"hello\"\n2) \"world\"\n127.0.0.1:6379> hgetall myhash								#获取全部的字段\n1) \"field\"\n2) \"hello\"\n3) \"field2\"\n4) \"world\"\n127.0.0.1:6379> \n	\n127.0.0.1:6379> hdel myhash field					#删除hash指定的key字段！对应的value值也就消失了\n(integer) 1\n127.0.0.1:6379> hgetall myhash\n1) \"field2\"\n2) \"world\"\n127.0.0.1:6379> \n################################################################################################################\nhlen \n\n127.0.0.1:6379> hgetall myhash\n1) \"field2\"\n2) \"world\"\n3) \"field1\"\n4) \"hello\"\n127.0.0.1:6379> hlen myhash					#获取hash表的字段数量！\n(integer) 2\n127.0.0.1:6379> \n################################################################################################################\n127.0.0.1:6379> Hexists myhash field1				#判断hash中的指定字段是否存在！\n(integer) 1\n127.0.0.1:6379> hexists myhash filed3\n(integer) 0\n127.0.0.1:6379> \n################################################################################################################\n#只获得所有的field\n#只获得所有的value\n\n127.0.0.1:6379> hkeys myhash				#只获得所有的field\n1) \"field2\"\n2) \"field1\"\n127.0.0.1:6379> hvals myhash				#只获得所有的value\n1) \"world\"\n2) \"hello\"\n127.0.0.1:6379> \n################################################################################################################\nincr   decr\n\n127.0.0.1:6379> hincrby myhash fiedl3 1 			#指定增量\n(integer) 7\n127.0.0.1:6379> hincrby myhash fied3 -1\n(integer) -1\n127.0.0.1:6379> hincrby myhash fiedl3 -1\n(integer) 6\n127.0.0.1:6379> hsetnx myhash field4 hello				#如果不存在可以设置\n(integer) 1\n127.0.0.1:6379> hsetnx myhash field4 word				#如果存在则不可以设置\n(integer) 0\n127.0.0.1:6379> \n```\n\nhash应用场景：\n\n​	hash变更数据 user name age ，尤其是用户信息之类的，经常变动的信息！hash更适合于对象的存储，String更加适合字符串存储\n\n\n\n#### Zset（有序集合）\n\n在set的基础上，增加了一个值，set k1 v1  zset k1 score1 v1\n\n```bash\n127.0.0.1:6379> zadd mytset 1 one 				#添加一个值\n(integer) 1\n127.0.0.1:6379> zadd mytset 2 two 3 three		#添加多个值\n(integer) 2\n127.0.0.1:6379> zrange mytset 0 -1				#查看所有的值\n1) \"one\"\n2) \"two\"\n3) \"three\"\n127.0.0.1:6379> \n################################################################################################################\n排序\n\n127.0.0.1:6379> zadd salary 2500 xiaohong			#添加三个用户\n(integer) 1\n127.0.0.1:6379> zadd salary 5000 zhangsan\n(integer) 1\n127.0.0.1:6379> zadd salary 50  guoshun\n(integer) 1\n127.0.0.1:6379> ZRANGEByscore salary -inf +inf		显示全部用户 从小到大\n1) \"guoshun\"\n2) \"xiaohong\"\n3) \"zhangsan\"\n127.0.0.1:6379> ZRANGEByscore salary -inf +inf\n1) \"guoshun\"\n2) \"xiaohong\"\n3) \"zhangsan\"\n127.0.0.1:6379> zrangebyscore salary -inf +inf withscores		#显示所有用户，并且附带成绩\n1) \"guoshun\"\n2) \"50\"\n3) \"xiaohong\"\n4) \"2500\"\n5) \"zhangsan\"\n6) \"5000\"\n127.0.0.1:6379> zrangebyscore salary -inf 50 withscores			#显示工资小于50 员工的升序排序\n1) \"guoshun\"\n2) \"50\"\n127.0.0.1:6379> zrevrange salary 0 -1							#从大到小进行排序\n1) \"zhangsan\"\n2) \"guoshun\"\n127.0.0.1:6379> \n\n################################################################################################################\n移除rem 中的 \n\n127.0.0.1:6379> zrange salary 0 -1\n1) \"guoshun\"\n2) \"xiaohong\"\n3) \"zhangsan\"\n127.0.0.1:6379> zrem salary xiaohong			#移除有序集合中的元素\n(integer) 1\n127.0.0.1:6379> zcard salary\n(integer) 2\n################################################################################################################\n\n```\n\n案列思路：set 排序，存储班级成绩，工资表排序\n\n\n\n普通消息：重要消息 2、带权重进行判断\n\n排行榜应用实现，取top N测试\n\n\n\n### 三种特殊数据类型\n\n#### geospatial  地理位置\n\n朋友的定位，附近的人，打车距离计算\n\n\n\nRedis的Geo，版本就推出了！这个功能可以推算地理位置信息，两地之间的距离，方圆几里的人！\n可以查询一些测试数据\n\n>geoadd\n\n```bash\n#geoadd 添加地理位置信息、\n#规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入\n有效经度从-180到180度。\n\n有效纬度从 -85.05112878 到 85.05112878 度。\n#参数 key 值（经度、维度、名称）\n127.0.0.1:6379> geoadd china:city 112.98 28.1844 chgangsha\n(integer) 1\n127.0.0.1:6379> geoadd china:city 115.54226 34.826 heze\n(integer) 1\n127.0.0.1:6379> geoadd china:city 120.369 36.09 qingdao\n(integer) 1\n127.0.0.1:6379> geoadd china:city 116.49 39.90 beijing 114.05 22.52 shengzhen\n(integer) 2\n127.0.0.1:6379> geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian\n(integer) 2\n127.0.0.1:6379> \n\n```\n\n\n\n> geopos \n\n获得当前定位：一定是一个坐标值\n\n```bash\n127.0.0.1:6379> geopos china:city chgangsha			#获取城市的经度和纬度、\n1) 1) \"112.9800000786781311\"\n   2) \"28.18439976131180202\"\n127.0.0.1:6379> geopos china:city heze\n1) 1) \"115.54226070642471313\"\n   2) \"34.82600034434852176\"\n127.0.0.1:6379> \n\n```\n\n\n\n>Geodist\n\n两人之间的距离\n\n单位：\n\n- **m** 表示单位为米。\n- **km** 表示单位为千米。\n- **mi** 表示单位为英里。\n- **ft** 表示单位为英尺。\n\n```bash\n127.0.0.1:6379> geodist china:city  chgangsha  beijing     #查看长沙到北京的直线距离\n\"1342311.5318\"\n127.0.0.1:6379> geodist china:city  chgangsha  beijing  km		#查看长沙到北京的直线距离\n\"1342.3115\"\n127.0.0.1:6379> geodist china:city chgangsha heze km\n\"777.5632\"\n127.0.0.1:6379> \n\n```\n\n>georadius \n\n我附近的人？（获得所有人的地址，定位！）通过半径来查询\n\n获得指定数量的人，200\n\n所有数据应该都录入：china：city，才会让结果更加清晰\n\n```bash\n127.0.0.1:6379> GEORadius china:city 112 20 10000 km			#以112 20 这个经纬度为中心，寻找方圆1000km的城市\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n7) \"beijing\"\n127.0.0.1:6379> GEORadius china:city 112 20 10000 km withdis				#显示到中间距离的位置\n1) 1) \"xian\"\n   2) \"1614.1206\"\n2) 1) \"shengzhen\"\n   2) \"351.7187\"\n3) 1) \"chgangsha\"\n   2) \"915.7281\"\n4) 1) \"hangzhou\"\n   2) \"1403.3277\"\n5) 1) \"heze\"\n   2) \"1685.3538\"\n6) 1) \"qingdao\"\n   2) \"1967.0316\"\n7) 1) \"beijing\"\n   2) \"2254.4608\"\n127.0.0.1:6379> georadius china:city 112 20 500 km withdist withcoord count 1  #筛选出指定的结果\n1) 1) \"shengzhen\"\n   2) \"351.7187\"\n   3) 1) \"114.04999762773513794\"\n      2) \"22.5200000879503861\"\n127.0.0.1:6379> \n\n```\n\n\n\n> GEORaDiusBymenber\n\n```bash\n#找出位于指定元素周围的其他元素\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing  4000 km 			#\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n7) \"beijing\"\n127.0.0.1:6379> GEORADIUSBYMEMBER china:city beijing  1000 km \n1) \"heze\"\n2) \"qingdao\"\n3) \"beijing\"\n4) \"xian\"\n127.0.0.1:6379> \n\n```\n\n> GEO 底层的实现原理其实就是Zset! 我们可以使用Zset命令来操作 geo\n\n```bash\n127.0.0.1:6379> zrange china:city 0 -1						#查看地图中全部元素\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n7) \"beijing\"\n127.0.0.1:6379> zrem china:city beijing						#移除指定元素\n(integer) 1\n127.0.0.1:6379> zrange china:city 0 -1\n1) \"xian\"\n2) \"shengzhen\"\n3) \"chgangsha\"\n4) \"hangzhou\"\n5) \"heze\"\n6) \"qingdao\"\n127.0.0.1:6379> \n```\n\n\n\n\n\n#### Hyperloglog\n\n\n\n基础（不重复的元素）\n\n> 简介\n\nRedis 2.8.9版本就更新了，Hyperloglog数据结构\n\n\n\nredis Hyperloglog 基数统计算法\n\n优点：占用的内存是固定的！如果从内存角度来比较的话，Hyperloglog首选\n\n\n\n> 测试使用\n\n```bash\n127.0.0.1:6379> Pfadd mykey a b c d e f g h i  j  			#创建第一组元素 \n(integer) 1\n127.0.0.1:6379> pfcount mykey								#统计mykey中的基数数量\n(integer) 10	\n127.0.0.1:6379> pfadd mykey2 k l m n o p q r s t 			#创建第二组\n(integer) 1\n127.0.0.1:6379> pfcount mykey2\n(integer) 10\n127.0.0.1:6379> pfmerge mykey3 mykey mykey2					#合并两组\nOK\n127.0.0.1:6379> pfcount mykey3								#看并集的数量\n(integer) 19\n127.0.0.1:6379> \n```\n\n如果允许容错，那么一定可以使用 Hyperloglog\n\n如果不允许那么就使用set或者自己的数据类型即可！\n\n\n\n\n\n#### Bitmap\n\n>位存储\n\n应用场景：\n\n统计用户信息：活跃，不活跃！ 登录、未登录！两个状态的都可以使用  Bitmaps\n\nBitmap位图，数据结构！都是操作二进制位来进行记录，就只有0和1两个状态\n\n365天=365bit 1字节=8bit 46字节左右\n\n\n\n使用bitmaps来记录周一到周日的打卡\n\n周一:1 周二：0  周三:1   \n\n![image-20201107143207558](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201107143207558.png)\n\n查看某一天是否打卡\n\n```bash\n127.0.0.1:6379> getbit sign 0	\n(integer) 1\n127.0.0.1:6379> getbit sign 6\n(integer) 0\n127.0.0.1:6379> \n\n```\n\n\n\n统计操作,统计打卡的天数\n\n```bash\n127.0.0.1:6379> bitcount sign 			#统计这周打卡记录，就可以看到是否有全勤\n(integer) 3\n127.0.0.1:6379> \n\n```\n\n\n\n## 事务\n\nRedis事务本质：一组命令的集合！一个事务中的所有命令都叫被序列化，在事务执行过程中，会按照顺序执行。\n\n一次性、顺序性、排他性！执行一些列的命令！\n\n==Redis事务没有隔离级别的概念==\n\n所有的命令在事务中，并没有直接执行！只有发起执行命令的时候才会执行！Exec\n\n==Redis单条命令是保存原子性的，但是事务是不保存原子性的。==\n\n\n\nRedis事务\n\n- 开启事务（multi）\n- 命令入队（.....）\n- 执行事务（exec）\n\n> 正常执行事务！\n\n```bash\n127.0.0.1:6379> multi							#开启事务\nOK\n\n#命令入队\n127.0.0.1:6379> set k1 v1\nQUEUED\n127.0.0.1:6379> set k2 v2 \nQUEUED\n127.0.0.1:6379> get k2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n\n#执行事务\n127.0.0.1:6379> exec\n1) OK\n2) OK\n3) \"v2\"\n4) OK\n\n```\n\n> 放弃事务\n\n```bash\n127.0.0.1:6379> MULTI \nOK\n127.0.0.1:6379> set k1 v1 \nQUEUED\n127.0.0.1:6379> set k4 v4\nQUEUED\n127.0.0.1:6379> DISCARD											#取消事务\nOK\n127.0.0.1:6379> get k4											#事务队列中命令都不会被执行\n(nil)\n127.0.0.1:6379> \n\n```\n\n> 编译型异常（代码有问题！命令有错），事务中所有的命令都不会被执行\n\n```bash\n127.0.0.1:6379> multi \nOK\n127.0.0.1:6379> set k1 v1 \nQUEUED\n127.0.0.1:6379> set k2 v2 \nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> getset k3									#错误的命令\n(error) ERR wrong number of arguments for \'getset\' command	\n127.0.0.1:6379> set k4 v4\nQUEUED\n127.0.0.1:6379> set k5 v5\nQUEUED\n127.0.0.1:6379> exec										#执行事务报错\n(error) EXECABORT Transaction discarded because of previous errors.  #所有的命令都不会执行\n127.0.0.1:6379> \n\n```\n\n\n\n\n\n> 运行时异常（1/0）,如果事务队列中存在语法中错误，其他命令是可以正常执行的，错误命令会抛出异常\n\n```bash\n127.0.0.1:6379> set k1 \"v1\"\nOK\n127.0.0.1:6379> MULTI\nOK\n127.0.0.1:6379> incr k1\nQUEUED\n127.0.0.1:6379> \n127.0.0.1:6379> set k2 v2\nQUEUED\n127.0.0.1:6379> set k3 v3\nQUEUED\n127.0.0.1:6379> exec\n1) (error) ERR value is not an integer or out of range					#虽然第一条命令报错了，但是依旧正常执行成功了\n2) OK\n3) OK\n127.0.0.1:6379> get k2\n\"v2\"\n127.0.0.1:6379> get k3\n\"v3\"\n127.0.0.1:6379> \n\n```\n\n\n\n> 监控！Watch （面试常问）\n\n**悲观锁：**\n\n- 很悲观，什么时候都会出问题，无论做什么都会加锁！\n\n**乐观锁：**\n\n- 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据，version！\n- 获取version\n- 更新的时候比较version\n\n> Redis测监视测试\n\n正常执行成功\n\n```bash\n127.0.0.1:6379> set money 100\nOK\n127.0.0.1:6379> set out 0\nOK\n127.0.0.1:6379> watch money		#监视money \nOK	\n127.0.0.1:6379> multi				#事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n127.0.0.1:6379> exec\n1) (integer) 80\n2) (integer) 20\n127.0.0.1:6379> \n\n```\n\n测试多线程修改完值，使用watch可以当做redis的乐观锁操作！\n\n```bash\n127.0.0.1:6379> set money 100\nOK\n127.0.0.1:6379> set out 0\nOK\n127.0.0.1:6379> watch money						#监视money\nOK\n127.0.0.1:6379> multi\nOK\n127.0.0.1:6379> decrby money 20\nQUEUED\n127.0.0.1:6379> incrby out 20\nQUEUED\n127.0.0.1:6379> exec							#执行之前，另一个线程，修改了我们的值，这个时候就会导致事务执行失败！\n1) (integer) 80\n2) (integer) 20\n127.0.0.1:6379> \n\n```\n\n如果修改失败，获取最新的值就好\n\n![image-20201107154225168](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201107154225168.png)\n\n\n\n\n\n## Jedis\n\n我们要使用java来操作Redis\n\n> 什么是Jedis  是redis官方推荐的java连接开发工具！使用java来操作Redis中间件！如果要使用Java操作Redis,那么一定要对Jedis十分的熟悉！\n\n> 测试\n\n1. 导入对应的依赖\n\n   ```xml\n       <dependencies>\n           <!--  导入jedis包-->\n           <dependency>\n               <groupId>redis.clients</groupId>\n               <artifactId>jedis</artifactId>\n               <version>3.2.0</version>\n           </dependency>\n   \n           <!--fastjson-->\n           <dependency>\n               <groupId>com.alibaba</groupId>\n               <artifactId>fastjson</artifactId>\n               <version>1.2.75</version>\n           </dependency>\n       </dependencies>\n   ```\n\n   \n\n2. 编码测试\n\n   1. 连接数据库\n   2. 操作命令\n   3. 断开连接\n\n   ```java\n   import redis.clients.jedis.Jedis;\n   \n   public class TestPing {\n       public static void main(String[] args) {\n           // 1、new 一个Jedis 对象即可\n           Jedis jedis = new Jedis(\"127.0.0.1\",6379);\n           //jedis 所有的命令就是我们之前学习的指令\n           System.out.println(jedis.ping());\n       }\n   }\n   ```\n\n   连接成功后输出pong\n\n### 常用APi\n\nString\n\nList\n\nSet \n\nHash\n\nZset\n\n> 所有api就是上面学习的指令\n\n\n\n\n\n## Spirngboot整合\n\n\n\nSpingBoot 操作数据：spring-data \n\nspringdata也是和springboot齐名的项目！\n\n说明：在spring2.x之后jedis被替换成了lettuce\n\njedis:	采用的是直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jeds连接池！\n\nlettuce:	采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像\n\n\n\n源码分析：\n\n```java\n	@Bean\n	@ConditionalOnMissingBean(name = \"redisTemplate\")	//我们可以自定义一个redisTemplate来替换这个默认的\n	public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n			throws UnknownHostException {\n        //默认的RedisTempate 没有过多的配置，redis 对象都是需要序列化！\n        //两个泛型都是Object，Object的类型，我们后使用需要强制转型<String,Object>\n		RedisTemplate<Object, Object> template = new RedisTemplate<>();\n		template.setConnectionFactory(redisConnectionFactory);\n		return template;\n	}\n\n	@Bean\n	@ConditionalOnMissingBean	//由于String是redis中最常使用的类型，所以说单独提出来了一个bean\n	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)\n			throws UnknownHostException {\n		StringRedisTemplate template = new StringRedisTemplate();\n		template.setConnectionFactory(redisConnectionFactory);\n		return template;\n	}\n```\n\n\n\n> 整合测试\n\n1. 导入依赖\n\n   ```xml\n   <!--操作redis-->\n           <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-data-redis</artifactId>\n           </dependency>\n   ```\n\n   \n\n2. 配置连接\n\n   ```xml\n   #配置redis\n   spring.redis.host=127.0.0.1\n   spring.redis.port=6379\n   ```\n\n   \n\n3. 测试！\n\n   ```java\n   package com.zhaoguoshun;\n   \n   import org.junit.jupiter.api.Test;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.boot.test.context.SpringBootTest;\n   import org.springframework.data.redis.connection.RedisConnection;\n   import org.springframework.data.redis.core.RedisTemplate;\n   \n   @SpringBootTest\n   class Redis02SpringbootApplicationTests {\n   \n       @Autowired\n       private RedisTemplate redisTemplate;\n   \n       @Test\n       void contextLoads() {\n           //redisTemplate 操作不同的数据类型，api和我们的指令是一样的\n           // opsForValue() 操作字符串的 类似String\n           //opsForList() 操作List 类似List\n           //opsForSet() \n           //opsForHash\n           //opsForGeo（）\n           //opsForHyperLogLog() \n           \n           \n           //除啦基本的操作，我们常用的方法都可以直接通过redsTemplate来操作，比如事务和基本你的CRUD \n           \n           //获取reds的连接对象\n   //        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();\n   //        connection.flushAll();\n           \n           \n       }\n   \n   }\n   ```\n\n   \n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108101356250.png\" alt=\"image-20201108101356250\" style=\"zoom:50%;\" />\n\n![image-20201108101542746](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108101542746.png)\n\n\n\n对象的保存：\n\n![image-20201108152348100](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108152348100.png)\n\n\n\n我们来编写一个自己的RedisTemplete\n\n```java\n    //这是一个固定模板，在企业中拿去就可以直接使用1\n    //编写我们自己的redisTemplate\n    @Bean\n    @SuppressWarnings(\"all\")\n    public RedisTemplate<String ,Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n\n        //json的序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(Object.class);\n\n\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n\n        //String的序列化\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n        //key采用String的序列化方式\n        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);\n        //Hash的key也采用String的序列化方式\n        redisTemplate.setHashKeySerializer(stringRedisSerializer);\n        redisTemplate.setConnectionFactory(redisConnectionFactory);\n        //value序列化方式采用jackson\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);\n        //hash的value序列化方式采用jackson\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n```\n\n\n\n所有的redis操作，对于java开发人员来说十分的简单，更总要的是要去理解redis的思想，和每一种数据类型，和应用场景。\n\n\n\n\n\n\n\n## Redis.conf详解\n\n启动的时候，就通过配置文件来启动！\n\n> 单位\n\n![image-20201108184458109](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108184458109.png)\n\n1. 配置文件 unit单位对大小写不敏感\n\n> 包含\n\n![image-20201108184853056](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201108184853056.png)\n\n> 网络\n\n```bash\n bind 127.0.0.1  #绑定你的ip\n protected-mode no  #保护模式\n port 6379  		#端口设置\n\n```\n\n> 通用  GENERAL\n\n```bash\ndaemonize yes   #默认是no 以守护进程的方式运行，我们需要自己开启为yes\npidfile /var/run/redis_6379.pid   #如果以后台的方式运行，我们就需要指定一个pid文件！\n\n\n#日志\n# Specify the server verbosity level.\n# This can be one of:\n# debug (a lot of information, useful for development/testing)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)		生产环境使用\n# warning (only very important / critical messages are logged)\nloglevel notice\nlogfile \"\"  		#日志默认的文件名\ndatabases 16        #数据库的数量默认 16个\nalways-show-logo yes   #是否总是显示logo\n\n```\n\n> 快照\n\n持久化，在规定的时间内，执行了多少次操作则会持久化到文件 .rdb.aof\n\nredis是内存数据库，没有持久化，数据断电就没了\n\n```bash\n#如果900秒内，如果至少有一个key进行了修改，我们就进行了持久化\nsave 900 1\n#如果300秒内，如果至少有一个10key进行了修改，我们就进行了持久化\nsave 300 10\n#如果60秒内，如果至少有一个10000key进行了修改，我们就进行了持久化\nsave 60 10000\nstop-writes-on-bgsave-error yes				#持久化出现错误之后，是否继续工作\nrdbcompression yes				#是否压缩rdb文件，需要消耗cpu资源\nrdbchecksum yes 				#保存rdb文件的时候，进行错误的检查校验\ndir ./							#rdb文件保存的目录\n \n```\n\n> REPLICATION  复制，我们后面讲主从复制的时候再进行讲解\n\n\n\n\n\n> SECURITY 安全\n\n可以在这里设置redis的密码，默认是没有密码的！\n\n```bash\n127.0.0.1:6379> config get requirepass					#获取redis的密码\n1) \"requirepass\"\n2) \"\"\n127.0.0.1:6379> config set requirepass \"985211\"			#设置redis的面膜\nOK\n127.0.0.1:6379> config get requirepass					#发现所有的命令都没有权限了\n(error) NOAUTH Authentication required.\n127.0.0.1:6379> ping\n(error) NOAUTH Authentication required.	\n127.0.0.1:6379> auth 985211								#使用密码进行登录\nOK\n127.0.0.1:6379> ping\nPONG\n127.0.0.1:6379> \n\n```\n\n> 限制 CLIENTS\n\n```bash\nmaxclients 10000  #设置redis的最大客户端的数量\n\nmaxmemory <bytes> #redis最大内存数量\naxmemory-policy noeviction	#内存到达上限的成功优酷策略\n	#移除一些过期的key\n	#报错\nnoeviction: 不进行置换，表示即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error\n    \nallkeys-lru: 优先删除掉最近最不经常使用的key，用以保存新数据\n    \nvolatile-lru: 只从设置失效（expire set）的key中选择最近最不经常使用的key进行删除，用以保存新数据\n    \nallkeys-random: 随机从all-keys中选择一些key进行删除，用以保存新数据\n    \nvolatile-random: 只从设置失效（expire set）的key中，选择一些key进行删除，用以保存新数据\n    \nvolatile-ttl: 只从设置失效（expire set）的key中，选出存活时间（TTL）最短的key进行删除，用以保存新数据\n \n```\n\n> APPEND ONLY MODE 模式，aof配置\n\n```bash\nappendonly no		#默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部门情况下，rdb完全够用！\nappendfilename \"appendonly.aof\"			#持久化文件的名字\n	\n# appendfsync always		#每次修改都会 sync 消耗性能\nappendfsync everysec		#每秒执行一次	sync 可能会丢失这一秒数据\n# appendfsync no			#不执行 sync 这个时候操作系统自己同步数据，速度快\n```\n\n\n\n\n\n## Redis持久化\n\n\n\nRedis是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。\n\n\n\n### RDB(Redis DataBase)\n\n\n\n> 什么是RDB?\n\n![image-20201109092815426](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109092815426.png)\n\n在指定的时间间隔内将内存中的数据集快照写入磁盘。\n\nredis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。我们默认就是RDB,一般不需要修改这个配置。\n\n有时候在生产环境我们会将这个dump.rdb备份\n\n==rdb保存的文件是 dump.rdb==\n\n![image-20201109093825315](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109093825315.png)\n\n![image-20201109094109819](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109094109819.png)\n\n\n\n> 触发机制\n\n1. save的规则满足情况下，会自动触发rdn规则\n2. 执行flushdb 、flushall 也会触发我们的rdb规则\n3. 退出redis，也会产生rdb文件\n\n备份就会自动生成一个dump.rdb文件\n\n\n\n> 如果恢复rdb文件！\n\n1. 只需要将rdb文件放在redis目录就可以了，redis启动的时候回自动检查dump.rdb 恢复其中的数据！\n2. 查看需要存在的位置\n\n```bash\n127.0.0.1:6379> config get dir						#查看我们\n1) \"dir\"\n2) \"/usr/local/redis/bin\"							#如果在这个目录下存在dump这个文件，启动的时候就会自动恢复其中的数据\n127.0.0.1:6379> \n\n```\n\n> 几乎就他自己默认的配置就够用了，但是我们还是需要去学习\n\n优点：\n\n1. 适合大规模的数据恢复！\n2. 如果你对数据的完整性要求不高\n\n缺点：\n\n1. 需要一定的时间间隔，如果redis意外宕机了\n2. fork进程的时候，会占用一定的内存空间。\n\n\n\n## AOF (Append Only File)\n\n将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部执行一遍\n\n> 是什么\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109102115334.png\" alt=\"image-20201109102115334\" style=\"zoom:50%;\" />\n\n\n\n> append\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109102423377.png\" alt=\"image-20201109102423377\" style=\"zoom:50%;\" />\n\n默认是不开启的，需要手动配置！我们就需要将 appendoly 改为yes开启了aof!\n\n重启，redis就可以生效了。\n\n\n\n如果这个aof文件有错误，这时候，redis是启动不起来的，我们需要修复这个aof文件\n\nredis给我们提供了一个工具`redis-check-aof `\n\n![image-20201109104034460](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109104034460.png)\n\n如果文件正常，重启就可以直接恢复了！\n\n![image-20201109104245563](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109104245563.png)\n\n==恢复以后发现我们有错误的那一行数据被丢弃，找不到了==\n\n\n\n> 重写规则说明\n\naof默认就是文件的无限追加，文件会越来越大\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109105158979.png\" alt=\"image-20201109105158979\" style=\"zoom: 50%;\" />\n\n\n\n如果aof文件大于64m ，太大了！fork一个新的进程来将我们的文件进行重写！\n\n> 优点和缺点\n\n优点：\n\n1. 每一次修改都同步，文件完整会更好\n2. 每秒同步一次，可能会丢失一秒的数据\n3. 从不同步，效率是最高的\n\n缺点：\n\n1. 相对于数据文件来说，aog远远大于rdb，修复的速度也比rdb慢\n2. Aof运行效率也比rdb慢，所有我们redis默认配置就是rdb\n\n\n\n\n\n## Redis发布订阅\n\nredis发布订阅是一种==消息通信模式==：发送者（pub）发送消息，订阅者（sub）接受消息。\n\nredis可以订阅任意数量的频道\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109144148795.png\" alt=\"image-20201109144148795\" style=\"zoom: 67%;\" />\n\n> 命令\n\n这些命令被广泛构建即时通信应用，比如网络聊天室和实时广播，实时提醒等。\n\n![image-20201109145021914](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109145021914.png)\n\n> 测试\n\n订阅端：\n\n```bash\n127.0.0.1:6379> SUBSCRIBE zhaoguoshun				#订阅以一个频道\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"zhaoguoshun\"\n3) (integer) 1\n\n#等待推送信息\n1) \"message\"\n2) \"zhaoguoshun\"\n3) \"helloo\"\n1) \"message\"\n2) \"zhaoguoshun\"\n3) \"guoshun\"\n\n```\n\n发送端：\n\n```bash\n127.0.0.1:6379> PUBLISH zhaoguoshun \"helloo\"			#发布者发布消息到频道 \n(integer) 1\n127.0.0.1:6379> publish zhaoguoshun guoshun\n(integer) 1\n127.0.0.1:6379> \n\n```\n\n\n\n> 原理\n\n1. Redis是用C实现的，通过分析Redis源码里的pubsub.c文件，了解发布和订阅机制的底层实现，即此加深对redis的理解\n2. Redis 通过PUBLISH 、SUBSCRIBE 、 PSUBSCRUBE 等命令实现发布和订阅的功能\n\n\n\n使用场景:\n\n1. ​	实时消息系统！\n2. 实时聊天！（聊天室，将信息给回显给所有人）\n3. 订阅、关注系统都是可以的\n\n稍微复杂的场景我们就会使用消息中间件 MQ()\n\n\n\n\n\n\n\n## Redis主从复制\n\n==默认情况下，每台服务器都是一个主节点；==\n\n\n\n\n\n主从复制的作用主要包括：\n\n1. 数据冗余 ：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式\n2. 故障恢复：当主节点出现问题时，可以由节点提供服务，实现快速的故障恢复；实际是一种服务的沉余\n\n主从复制，读写分离! 80%的情况下都是在进行读操作！减缓服务器的压力！架构经常使用！\n\n\n\n==单台Redis最大使用内存不应该超过20G==\n\n\n\n\n\n只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用redis!\n\n\n\n### 环境配置\n\n只配置从库，不用配置主库\n\n```bash\n127.0.0.1:6379> inf replication			\n(error) ERR unknown command `inf`, with args beginning with: `replication`, \n127.0.0.1:6379> info replication			#查看当前库的信息	\n# Replication\nrole:master						#角色 master\nconnected_slaves:0				#没有从机\nmaster_replid:ef682f65b4fbba8840024aa9fc3e74456ee16ba6\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:0\nsecond_repl_offset:-1\nrepl_backlog_active:0\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:0\nrepl_backlog_histlen:0\n127.0.0.1:6379> \n\n```\n\n复制3个配置文件，修改对应信息\n\n1. 端口\n2. pid名字\n3. log文件名字\n4. dump.rdb 文件\n\n修改完毕之后，启动我们的三个redis服务器，可以通过进程信息查看！\n\n![image-20201109172704125](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201109172704125.png)\n\n### 一主二从\n\n==默认情况下，每台Redis服务器都是主节点；==我们一般情况下，只用配置之从机就好了\n\n\n\n认老大\n\n```bash\n127.0.0.1:6380> SLaveof 127.0.0.1 6379			#SLaveof   host 6379 \nOK\n127.0.0.1:6380> info replication\n# Replication\nrole:slave\nmaster_host:127.0.0.1							#可以看到主机的信息\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:3\nmaster_sync_in_progress:0\nslave_repl_offset:28\nslave_priority:100\nslave_read_only:1\nconnected_slaves:0\nmaster_replid:13a460c853effea31b096e1652826fbbaf619caf\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:28\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:28\n127.0.0.1:6380> \n\n#在主机中查看\n127.0.0.1:6379> info replication\n# Replication\nrole:master\nconnected_slaves:1				#多了从机的配置\nslave0:ip=127.0.0.1,port=6380,state=online,offset=182,lag=0\nmaster_replid:13a460c853effea31b096e1652826fbbaf619caf\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:182\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:182\n127.0.0.1:6379> \n\n```\n\n两个都配置完以后，\n\n![image-20201110092137064](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110092137064.png)\n\n真实的主从配置，应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，是暂时的\n\n\n\n> 配置文件中配置主机\n\n![image-20201110102633198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110102633198.png)\n\n这里写上主机的IP，和端口\n\n启动了主机和从机就可以看到配置成功\n\n![image-20201110102739862](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110102739862.png)\n\n![image-20201110102805319](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110102805319.png)\n\n> 细节\n\n主机可以写从机只能读！主机中的所有信息和数据，都会自动被从机保存\n\n\n\n主机写：\n\n![image-20201110093042065](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110093042065.png)\n\n从机只能读取内容：\n\n![image-20201110093203284](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110093203284.png)\n\n\n\n测试：主机断开连接，从机依旧连接到主机的，但是没有写操作了买这个时候，如果主机回来了，依旧可以直接获取到主机写的信息！\n\n\n\n如果是使用命令行，来配置的主从，如果重启了，就会变回主机！只要变为从机立马就会从主机中获取值！\n\n> 复制原理\n\n- Slave 启动成功连接到master后会发送一个sync命令\n\n- Master 接到命令，启动后台的存盘进程，同时收集所有的用于修改数据集命令，在后台进程执行完毕之后，==master将传送整个数据文件到slave，并完成一次完全同步。==\n\n- 全量复制：而Slave服务在接收到数据库文件时，将其存盘并加载到内存中\n\n- 增量复制：Master继续新的所有收集，到的修改命令依次传给slave，完成同步\n\n  但是只要是重新连接master，一次完全同步（全量复制）将被自动执行\n\n\n\n> 层层链路\n\n上一个master链接下一个S\n\n![image-20201110095841711](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110095841711.png)\n\n\n\n> 如果主机断开，这个时候能不能选择一个主机？\n\n==谋朝篡位==\n\n如果主机断开了连接，我们可以使用 ·`SLAveof no one`使自己变成主机\n\n\n\n\n\n\n\n## 哨兵模式\n\n（自动选举老大的模式）\n\n> 概述\n\n主从技术的方法是，当服务器宕机后，需要手动配置一台服务器切换为主服务器，这就是得需要人工干预，费时费力，还会造成一段时间内服务不可用。这不是一种推荐方式更多的时候，我们优先考虑哨兵模式。\n\n\n\n能够后台监控主机是否故障，如果故障了个根据票数==自动将从库转换为主库。==\n\n\n\n哨兵是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，他会独立运行。其原理是哨兵通过发送命令，等待Redis服务响应，从而监控运行的多个Redis实例\n\n![image-20201110144951985](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110144951985.png)\n\n我配置一个哨兵，如果哨兵宕机了怎么办？通常情况下我们会配置多个哨兵模式。\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110145102170.png\" alt=\"image-20201110145102170\" style=\"zoom:67%;\" />\n\n\n\n假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为这个服务器不可用，这个现象称之为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover故障转移操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称之为**客观下线**。\n\n\n\n> 测试\n\n1. 配置哨兵配置文件 sentinel.conf\n\n   ```bash\n   #sentinel monitor  被监控的名称 127.0.0.1 6379 1\n   sentinel monitor myredis 127.0.0.1 6379 1\n   ```\n\n   后面这个数字，代表主机挂了，slave投票看谁接替成为主机，票数最多的，就会成为主机！\n\n2. 启动哨兵\n\n   ```bash\n   [root@guoshun bin]# redis-sentinel guoshunconfig/sentinel.conf \n   16482:X 10 Nov 2020 15:19:17.834 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\n   16482:X 10 Nov 2020 15:19:17.834 # Redis version=5.0.8, bits=64, commit=00000000, modified=0, pid=16482, just started\n   16482:X 10 Nov 2020 15:19:17.834 # Configuration loaded\n                   _._                                                  \n              _.-``__ \'\'-._                                             \n         _.-``    `.  `_.  \'\'-._           Redis 5.0.8 (00000000/0) 64 bit\n     .-`` .-```.  ```\\/    _.,_ \'\'-._                                   \n    (    \'      ,       .-`  | `,    )     Running in sentinel mode\n    |`-._`-...-` __...-.``-._|\'` _.-\'|     Port: 26379\n    |    `-._   `._    /     _.-\'    |     PID: 16482\n     `-._    `-._  `-./  _.-\'    _.-\'                                   \n    |`-._`-._    `-.__.-\'    _.-\'_.-\'|                                  \n    |    `-._`-._        _.-\'_.-\'    |           http://redis.io        \n     `-._    `-._`-.__.-\'_.-\'    _.-\'                                   \n    |`-._`-._    `-.__.-\'    _.-\'_.-\'|                                  \n    |    `-._`-._        _.-\'_.-\'    |                                  \n     `-._    `-._`-.__.-\'_.-\'    _.-\'                                   \n         `-._    `-.__.-\'    _.-\'                                       \n             `-._        _.-\'                                           \n                 `-.__.-\'                                               \n   \n   16482:X 10 Nov 2020 15:19:17.835 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\n   16482:X 10 Nov 2020 15:19:17.835 # Sentinel ID is b3fd3fbdc8199bfdb03544b1ee4e575925f38fc7\n   16482:X 10 Nov 2020 15:19:17.835 # +monitor master myredis 127.0.0.1 6379 quorum 1\n   \n   ```\n\n   如果主机（Master）节点断开了，这个时候会从随机中选择一个服务器！（这里面有一个投票算法）。\n\n   自己总结的实战发现:\n\n   ==当我们的主机宕机服务回来之后，不会在成为主服务器（不会在成为老大），会成为从节点（跟其新老大）==\n\n   ​	哨兵日志：\n\n   <img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110155131481.png\" alt=\"image-20201110155131481\" style=\"zoom:50%;\" />\n\n   此时如果主机回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则\n\n   > 哨兵模式\n\n\n\n优点：\n\n1. 哨兵集群，基于主从复制，所有的主机从配置优点，它全有\n2. 主从可以切换，故障可以转移，系统的可用性就会更好。\n3. 哨兵模式就是主从模式的升级，手动到自动，更加健壮！\n\n缺点：\n\n1. Redis不好再线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！\n2. 实现哨兵模式的配置其实是很麻烦的，里面有很多选择！\n\n> 哨兵模式的全部配置\n\n```bahs\nprotected-mode no       #关闭保护模式                                                                                                 \n\nport 26479                    #端口                                                                                           \n\ndaemonize yes             #使用后台模式启动                                                                                               \n\npidfile \"/var/run/redis-sentinel_26479.pid\"                       #进程id文件                                                       \n\nlogfile \"/usr/local/redis/sentinel/sentinel_26479.log\"           #日志文件                                                        \n\ndir \"/usr/local/redis/sentinel\" 　　　　　　　　　　　　　　#工作目录\n\n \n\n核心配置\n\n1、sentinel monitor <master-name> <ip> <port> <quorum>\n\nmaster-name：redis主节点昵称。\n\nip：redis主机ip。\n\nport：redis主机端口。\n\nquorum：哨兵判断主节点是否发生故障的票数。如果设置为2，表示2个哨兵节点认为主节点发生了故障，一般设置为：哨兵节点数/2+1。\n\n2、sentinel down-after-milliseconds <master-name> <times>\n\n哨兵会定期的向redis节点发送ping命令来判断redis是否可达，若超过指定的times毫秒内还未得到pong回复，则判读该redis不可达。\n\n3、sentinel parallel-syncs <master-name> <nums>\n\n当redis主节点挂了后，哨兵会选出新的master，此时，剩余的slave会向新的master发起同步数据，这个设置表示允许并行同步的slave个数。\n\n4、sentinel failover-timeout <master-name>  <times>\n\n进行故障转移时，如果超过设置的times毫秒，表示故障转移失败。\n\n5、sentinel auth-pass <master-name> <password>\n\n如果redis主节点设置了密码，则需要进行这个配置。\n\n \n\n*****备注配置redis主从复制、读写分离*******\n\n配置思路：master配置文件不需要动，修改slave的配置文件。\n\n1、添加一行：replicaof <masterip> <masterport>\n\n2、如果master配置有密码，则需要配置这一行\n\n　　masterauth <master-password>\n\n3、replica-read-only yes　　　　#表示slave中的数据是只读的\n\n \n\n*****springboot整合redis哨兵模式*******\n\n添加yml配置文件\n\nspring:\n\n　　redis:\n　　　　database: 0\n　　　　password: 12345678\n　　　　sentinel:\n　　　　　　master: mymaster\n　　　　　　nodes: 192.168.0.1:26379,192.168.0.1:26479,192.168.0.1:26579\n```\n\n\n\n\n\n## Redis缓存穿透和雪崩\n\n\n\n![image-20201110164708522](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201110164708522.png)\n\n\n\n### 缓存穿透（查不到）\n\n> 概念\n\n缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库中没有，也就是缓存中没有，于是向数据库查询。发现也没有，于是本次查询失败。当很多用户的时候，缓存都没有命中,于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。\n\n\n\n> 解决方案\n\n**布隆过滤器**\n\n布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合规则丢弃，从而避免了对底层储存系统的从查询压力。\n\n\n\n**缓存空对象**\n\n当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据会从缓存中获取，保护了后端的数据源；\n\n\n\n### 缓存击穿（量太大，缓存过期！）\n\n> 概述\n\n这里需要主要和缓存击穿的区别，缓存击穿，是指一个key非常热点，再不停的扛着大并发，大并发集中对这一个点访问，当这个key在失效的瞬间，持续的大并发就能穿破缓存，直接请求数据库。就像在屏幕上凿开了一个洞。\n\n\n\n> 解决方案\n\n**设置热点数据永不过期**\n\n从缓存层面来看，没有设置过期时间，所以不会出现热点key过期产生的问题。\n\n\n\n**加互斥锁**\n\n分布式锁：使用分布式锁，保证每一个key只有一个线程取查询后端服务，其他线程没有获得分布式锁的权限，因此需要等待即可。这种方式将高并发的压力转到了分布式锁，因此对分布式锁的考验很大。\n\n\n\n\n\n\n\n### 缓存雪崩\n\n\n\n> 概念\n\n缓存某个节点宕机，断电或者断网都可能会产生缓存雪崩的现象。\n\n\n\n**redis高可用**\n\n这会的思想含义是，既然redis可能挂掉，那就多增加几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。\n\n（异地多活）\n\n**限流降级**（在SpringCloud有）\n\n这个解决方案的思想是，在缓存失效后，通过加锁或队列来控制·数据库写缓存的线程数量。\n\n\n\n\n\n> 小结\n\n\n\n',NULL,0,0,0,NULL,'2021-01-01',356,'2021-01-01',12),
(61,42,'七大查找算法','http://8.135.100.252/image/2019-10-1/6ce331ef-d335-4705-8e79-0aaf5e886a3c.jpg','查找算法又分为四大类，分别是静态查找、动态查找、无序查找和有序查找','https://blog.csdn.net/qq_36427244/article/details/101199726','![Alt text](http://8.135.100.252/image/2019-10-1/6ce331ef-d335-4705-8e79-0aaf5e886a3c.jpg)\n[[toc]]\n## 顺序查找 \n  \n ``` mysql\npublic class OrderSearch {\n\n    public static void main(String[] args) {\n        int[] table = {1,23,4,5,6};\n        System.out.println(OrderSearch.orderSearch(table, 5));\n\n    }\n\n\n    /**\n     * 顺序查找\n     * @param table\n     * @param keyWord\n     * @return\n     */\n    public static boolean orderSearch(int[] table,int keyWord){\n        for(int i = 0;i&lt;table.length;i++){\n            if(table[i] == keyWord){\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n```\n \n ## 二分查找(折半查找) \n  \n ``` mysql\n /**\n     * 查找成功，则返回下标i，失败返回-1\n     * 假定为升序排列\n     * @param datas\n     * @return\n     */\n    public static int Binary_Search(int[] datas,int key,int start,int end) {\n        int mid = (end+start)/2;\n        //结束条件\n        if(start>end) {\n            return -1;\n        }\n        \n        if(datas[mid] == key) {\n            return mid;\n        }else if(datas[mid] >key){\n            return Binary_Search(datas,key,start,mid);\n        }else{\n            return Binary_Search(datas, key, mid, end);\n        }\n    }\n\n//测试main方法：\n\n    public static void main(String[] args) {\n        int[] datas = {1,2,3,4,5,6,7,8,9};\n        System.out.println(Binary_Search(datas, 2, 0, datas.length-1));\n    }\n\n```\n \n ## 插值查找 \n  \n ``` mysql\npublic class InsertValueSearch {\n    public static void main(String[] args) {\n        int arr[] = {1, 8, 10, 89, 1000, 1000, 1234};\n        int index = insertValueSearch(arr, 0, arr.length - 1, 89);\n        System.out.println(\"index = \" + index);\n    }\n \n    /**\n     * @param arr     数组\n     * @param left    左边索引\n     * @param right   右边索引\n     * @param findVal 查找值\n     * @return 如果找到，就返回对应的下标，如果没有找到，返回-1\n     */\n    public static int insertValueSearch(int[] arr, int left, int right, int findVal) {\n        \n        //注意:findVal &lt; arr[0] 和 findVal > arr[arr.length - 1] 必须需要\n        // 否则我们得到的 mid 可能越界\n        if (left > right || findVal &lt; arr[0] || findVal > arr[arr.length - 1]) {\n            return -1;\n        }\n \n        // 求出 mid, 自适应\n        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);\n        int midVal = arr[mid];\n \n        if (findVal > midVal) { // 说明应该向右边递归\n            return insertValueSearch(arr, mid + 1, right, findVal);\n        } else if (findVal &lt; midVal) { // 说明向左递归查找\n            return insertValueSearch(arr, left, mid - 1, findVal);\n        } else {\n            return mid;\n        }\n    }\n}\n```\n \n ## 斐波那契查找 \n  \n ``` mysql\npublic class FibonacciSearch {\n\n    public static void main(String[] args) {\n        int[] table = {1,2,3,4,5,6,7,8,9,10,11,12,13,14};\n        for(int i = 0;i&lt;table.length;i++){\n            System.out.println(\"表中记录为\"+table[i]+\"\\t,查询结果为\"+FibonacciSearch.fibonacciSearch(table, table[i])+\"\\n\");\n        }\n\n        for(int i = 0;i&lt;5;i++){\n            int ran = new Random().nextInt(100)+14;\n            System.out.println(\"关键字为：\"+ran+\"查询结果为\"+FibonacciSearch.fibonacciSearch(table, ran)+\"\\n\");\n        }\n\n    }\n\n    public static boolean fibonacciSearch(int[] table,int keyWord){\n        //确定需要的斐波那契数\n        int i = 0;\n        while(getFibonacci(i)-1 == table.length){\n            i++;\n        }\n        //开始查找\n        int low = 0;\n        int height = table.length-1;\n        while(low&lt;=height){\n            int mid = low + getFibonacci(i-1);\n            if(table[mid] == keyWord){\n                return true;\n            }else if(table[mid]>keyWord){\n                height = mid-1;\n                i--;\n            }else if(table[mid]&lt;keyWord){\n                low = mid+1;\n                i-=2;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 得到第n个斐波那契数\n     * @return\n     */\n    public static int getFibonacci(int n){\n        int res = 0;\n        if(n == 0){\n            res = 0;\n        }else if(n == 1){\n            res = 1;\n        }else{\n            int first = 0;\n            int second = 1;\n            for(int i = 2;i&lt;=n;i++){\n                res = first+second;\n                first = second;\n                second = res;\n            }\n        }\n        return res;\n    }\n}\n```\n \n ## 树表查找 \n  \n ### 二叉排序树的定义 \n  \n ### 二叉排序树的性质 \n  \n ### 二叉排序树的插入 \n  \n ### 二叉排序树的查找 \n  \n ### 二叉排序树的删除 \n  \n ### 二叉树的遍历 \n  \n  \n ``` mysql\n//二叉树结点\n class TreeNode {\n	\n	public Integer data;\n	\n	/*该节点的父节点*/\n	public TreeNode parent;\n	\n	/*该节点的左子节点*/\n	public TreeNode left;\n	\n	/*该节点的右子节点*/\n	public TreeNode right;\n	\n	public TreeNode(Integer data) {\n		this.data = data;\n		\n	}\n \n	@Override\n	public String toString() {\n		return \"TreeNode [data=\" + data + \"]\";\n	}\n}\n//二叉排序树\npublic class SearchTree {\n	\n     public TreeNode root;\n     public long size;\n	// 往树中加节点\n	public Boolean addTreeNode(Integer data) {\n \n		if (null == root) {\n			root = new TreeNode(data);\n			System.out.println(\"数据成功插入到平衡二叉树中\");\n			return true;\n		}\n \n		TreeNode treeNode = new TreeNode(data);// 即将被插入的数据\n		TreeNode currentNode = root;\n		TreeNode parentNode;\n \n		while (true) {\n			parentNode = currentNode;// 保存父节点\n			// 插入的数据比父节点小\n			if (currentNode.data > data) {\n				currentNode = currentNode.left;\n				// 当前父节点的左子节点为空\n				if (null == currentNode) {\n					parentNode.left = treeNode;\n					treeNode.parent = parentNode;\n					System.out.println(\"数据成功插入到二叉查找树中\");\n					size++;\n					return true;\n				}\n				// 插入的数据比父节点大\n			} else if (currentNode.data &lt; data) {\n				currentNode = currentNode.right;\n				// 当前父节点的右子节点为空\n				if (null == currentNode) {\n					parentNode.right = treeNode;\n					treeNode.parent = parentNode;\n					System.out.println(\"数据成功插入到二叉查找树中\");\n					size++;\n					return true;\n				}\n			} else {\n				System.out.println(\"输入数据与节点的数据相同\");\n				return false;\n			}\n		}		\n	}\n	 // 查找数据\n	public TreeNode findTreeNode(Integer data){\n		if(null == root){\n			return null;\n		}\n		TreeNode current = root;\n		while(current != null){\n			if(current.data > data){\n				current = current.left;\n			}else if(current.data &lt; data){\n				current = current.right;\n			}else {\n				return current;\n			}\n			\n		}\n		return null;\n	}\n}\n//二叉树遍历\nclass TreeOrder {\n     // 递归实现前序遍历\n	public static void preOrderMethodOne(TreeNode treeNode) {\n		if (null != treeNode) {\n			System.out.print(treeNode.data + \"  \");\n			if (null != treeNode.left) {\n				preOrderMethodOne(treeNode.left);\n			}\n			if (null != treeNode.right) {\n				preOrderMethodOne(treeNode.right);\n \n			}\n		}\n	}\n \n	 //循环实现前序遍历\n	public static void preOrderMethodTwo(TreeNode treeNode) {\n		if (null != treeNode) {\n			Stack&lt;TreeNode> stack = new Stack&lt;TreeNode>();\n			stack.push(treeNode);\n			while (!stack.isEmpty()) {\n				TreeNode tempNode = stack.pop();\n				System.out.print(tempNode.data + \"  \");\n				// 右子节点不为null,先把右子节点放进去\n				if (null != tempNode.right) {\n					stack.push(tempNode.right);\n				}\n				// 放完右子节点放左子节点，下次先取\n				if (null != tempNode.left) {\n					stack.push(tempNode.left);\n				}\n			}\n		}\n	}\n	\n	\n	 // 递归实现中序遍历\n	public static void medOrderMethodOne(TreeNode treeNode){\n		if (null != treeNode) {			\n			if (null != treeNode.left) {\n				medOrderMethodOne(treeNode.left);\n			}\n			System.out.print(treeNode.data + \"  \");\n			if (null != treeNode.right) {\n				medOrderMethodOne(treeNode.right);\n			}\n		}\n		\n	}\n	\n	 //循环实现中序遍历\n	public static void medOrderMethodTwo(TreeNode treeNode){	\n		Stack&lt;TreeNode> stack = new Stack&lt;TreeNode>();  \n        TreeNode current = treeNode;  \n        while (current != null || !stack.isEmpty()) {  \n            while(current != null) {  \n                stack.push(current);  \n                current = current.left;  \n            }  \n            if (!stack.isEmpty()) {  \n                current = stack.pop();  \n                System.out.print(current.data+\"  \");  \n                current = current.right;  \n            }  \n        }  		\n	}\n	\n     // 递归实现后序遍历\n	public static void postOrderMethodOne(TreeNode treeNode){		\n		if (null != treeNode) {		\n			if (null != treeNode.left) {\n				postOrderMethodOne(treeNode.left);\n			}\n			if (null != treeNode.right) {\n				postOrderMethodOne(treeNode.right);\n			}\n			System.out.print(treeNode.data + \"  \");\n		}\n	}\n	\n	 //循环实现后序遍历\n	public static void postOrderMethodTwo(TreeNode treeNode){\n		if (null != treeNode) {\n			Stack&lt;TreeNode> stack = new Stack&lt;TreeNode>();\n			TreeNode current = treeNode;\n			TreeNode rightNode = null;\n			while(current != null || !stack.isEmpty()) {  \n	            while(current != null) {  \n	                stack.push(current);  \n	                current = current.left;  \n	            }  \n	            current = stack.pop();  \n	            while (current != null &amp;&amp; (current.right == null ||current.right == rightNode)) {  \n	                System.out.print(current.data + \"  \");  \n	                rightNode = current;  \n	                if (stack.isEmpty()){  \n	                    System.out.println();  \n	                    return;  \n	                }  \n	                current = stack.pop();  \n	            }  \n	            stack.push(current);  \n	            current = current.right;  \n	        }  	\n		}\n	}\n}\n```\n \n ## 分块查找(索引查找) \n  \n - 主表:要查找的序列\n- 索引项:一般我们会将主表分成几个块，每个块建立一个索引，这个索引就叫索引项\n- 索引表:索引项的集合\n \n  \n - index,即索引项在主表的关键字\n- start,即块内的第1个元素在主表中的位置\n- length,即块的长度\n \n  \n ``` mysql\n//索引项\nclass IndexItem {\n    public int index;\n    public int start;\n    public int length;\n\n    public IndexItem(int index, int start, int length) {\n        this.index = index;\n        this.start = start;\n        this.length = length;\n    }\n\n    public int getIndex() {\n        return index;\n    }\n\n    public void setIndex(int index) {\n        this.index = index;\n    }\n\n    public int getStart() {\n        return start;\n    }\n\n    public void setStart(int start) {\n        this.start = start;\n    }\n\n    public int getLength() {\n        return length;\n    }\n\n    public void setLength(int length) {\n        this.length = length;\n    }\n}\n//索引查找\npublic class IndexSerach {\n	 // 主表\n    static int[] mainList = new int[]{\n            101, 102, 103, 104, 105, 0, 0, 0, 0, 0,\n            201, 202, 203, 204, 0, 0, 0, 0, 0, 0,\n            301, 302, 303, 0, 0, 0, 0, 0, 0, 0\n    };\n // 索引表\n    static IndexItem[] indexItemList = new IndexItem[]{\n            new IndexItem(1, 0, 5),\n            new IndexItem(2, 10, 4),\n            new IndexItem(3, 20, 3)\n    };\n    /**\n     * 索引查找算法\n     *\n     * @param key 给定值\n     * @return 返回给定值在表中的位置\n     */\n    public static int indexSearch(int key) {\n        IndexItem item = null;\n\n        // 建立索引规则\n        int index = key / 100;\n\n        // ① 遍历索引表，找到对应的索引项\n        for (int i = 0; i &lt; indexItemList.length; i++) {\n            // 找到索引项\n            if (indexItemList[i].index == index) {\n                item = indexItemList[i];\n                break;\n            }\n        }\n\n        // 索引表中不存在该索引项\n        if (item == null) {\n            return -1;\n        }\n\n        // ② 根据索引项，在主表中查找\n        for (int i = item.start; i &lt; item.start + item.length; i++) {\n            if (mainList[i] == key) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * 插入数据\n     *\n     * @param key 要插入的值\n     * @return true表示插入成功，false表示插入失败\n     */\n    public static boolean insert(int key) {\n        IndexItem item = null;\n\n        // 建立索引规则\n        int index = key / 100;\n        int i = 0;\n        // 遍历索引表，找到对应的索引项\n        for (i = 0; i &lt; indexItemList.length; i++) {\n            if (indexItemList[i].index == index) {\n                item = indexItemList[i];\n                break;\n            }\n        }\n        // 索引表中不存在该索引项\n        if (item == null) {\n            return false;\n        }\n\n        // 根据索引项将值插入到主表中\n        mainList[item.start + item.length] = key;\n        // 更新索引表\n        indexItemList[i].length++;\n\n        return true;\n    }\n    //遍历打印\n    public static void display(int[] list) {\n        System.out.println(\"********展示开始********\");\n        if (list != null &amp;&amp; list.length > 0) {\n            for (int i = 0; i &lt; list.length; i++) {\n                System.out.print(list[i] + \" \");\n                if ((i + 1) % 10 == 0) {\n                    System.out.println(\"\");\n                }\n            }\n        }\n        System.out.println(\"********展示结束********\");\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"********索引查找********\");\n        System.out.println(\"\");\n        System.out.println(\"原始数据：\");\n        display(mainList);\n        System.out.println(\"\");\n\n        int value = 202;\n        System.out.println(\"插入数据：\" + value);\n        // 插入成功\n        if (insert(value)) {\n            System.out.println(\"插入后的主表：\");\n            display(mainList);\n            System.out.println(\"\");\n\n            System.out.println(\"元素\" + value + \"在列表中的位置为：\" + indexSearch(value));\n        }\n    }\n}\n```\n \n ## 哈希查找 \n  \n - 用给定的哈希函数构造哈希表\n- 根据选择的冲突处理方法解决地址冲突\n- 在哈希表的基础上执行哈希查找\n \n  \n  \n  \n ``` mysql\n//采用除余法构建哈希函数,用链表法解决哈希冲突.\npublic class HashTableSearch { \n/* 哈希结点 */ \nprivate static class Node { \nint key; // 链表中的键 \nNode next; // 下一个同义词 \n}\n/*用求余，链表法构建哈希表*/\npublic Node[] createHashTable(int[] data, int p) {\n    Node[] hashtable = new Node[p];\n    int k;        //哈希函数计算的单元地址\n    for (int i = 0; i &lt; data.length; i++) {\n        Node node = new Node();\n        node.key = data[i];\n        k = data[i] % p;\n        if (hashtable[k] == null) {\n            hashtable[k] = node;\n        }else {\n            Node current = hashtable[k];\n            while(current.next != null) {\n                 current = current.next;\n            }\n            current.next = node;\n        }\n    }\n    return hashtable;\n}\n//是否为素数\npublic boolean isPrimes(int n) {\n    for(int i = 2; i &lt;= Math.sqrt(n); i++ ) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/* 在哈希表中查找关键字key */\npublic boolean HashSearch(int[] data, int key) {\n    int p = 1;\n    // 寻找小于或等于最接近表长的素数\n    for (int i = data.length; i > 1; i--) {\n        if (isPrimes(i)) {\n            p = i;\n            break;\n        }\n    }\n    // 构建哈希表\n    Node[] hashtable = createHashTable(data, p);\n    // 查找key是否在哈希表中\n    int k = key % p;\n    Node cur = hashtable[k];\n    while (cur != null &amp;&amp; cur.key != key) {\n        cur = cur.next;\n    }\n    if (cur == null) {\n        return false;\n    } else {\n        return true;\n    }\n}\npublic static void main(String[] args) {\n	int data[]= {1,3,66,56,34,67,343,77,31,64,0,5,6,32,55,23,56};\n	System.out.println(new HashTableSearch().HashSearch(data, 0));\n}\n}\n```',NULL,0,0,0,NULL,'2021-01-01',353,'2021-01-01',13),
(62,43,'Oracle数据库入门','http://8.135.100.252/image/2019-10-1/a869d5f2-8b0a-4b33-8941-0b7c63b4579f.jpg','Dubbo  ORM 单一应用架构 数据庞大不能分布  MVC架构 将单一应用分成多块 缺点不好维护  RPC 分布式架构 缺点不好调用   分布式服务框架 RPC      1601800132446 ','','![Alt text](http://8.135.100.252/image/2019-10-1/a869d5f2-8b0a-4b33-8941-0b7c63b4579f.jpg)\n# Oracle数据库的结构\n\n## 1、数据库database\nOracle数据库是数据的物理储存，这就包括（数据文件ORA或者DBF、控制文件、联机日志、参数文件）。其实Oracle数据库的概念和其他数据库不一样，这里的数据库时一个操作系统只有一个库，可以看做Oracle就只有一个大数据库。\n\n## 2、实例\n一个数据库可以有n个实例，有一系列的后台进程和内存结构组成。\n\n## 3、数据文件dbf\n是数据库的物理储存单位，数据库的数据是储存在表空间中的，真正是在某一个或者多个数据文件中，而一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间，一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。\n\n## 4、表空间\n表空间是Oracle对物理数据库上相关数据文件的逻辑映射，一个数据库在逻辑上被划分成一到若干个表空间，每个表空间包含了在逻辑上相关联的一组结构，每个数据库至少有一个表空间（称之为system表空间）\n\n每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件，一个数据文件只能属于一个表空间。\n\n## 5、用户\n用户是在实例下建立的，不同实例中可以建相同名字的用户，表的数据是由用户放入某一个表空间的，而这个表龙剑会随机把这些表数据进行管理和存放的，但是表不是由表空间去查询的，而是由用户去查询。\n\n## 6、SCOTT和HR用户\n是Oracle帮我们建好的测试账户，Scott账户常用，里面有emp、dept表等。\n\n# 安装篇\n\n``` shell\n\nSQL> create tablespace vuepress_blog datafile \'E:/oracle/tbspace/vuepress_blog.dbf\' size 100m;\n\n表空间已创建。\n\nSQL> create user admin identified by admin16 default tablespace vuepress_blog;\n\n用户已创建。\n\nSQL> grant dba to admin;\n\n授权成功。\n\n--查询当前实例对象\n\nSQL> select instance_name from v$instance;\n\nINSTANCE_NAME\n----------------\norcl\n\nSQL> conn admin/admin16@orcl\n\nSQL> select * from dual;\n\nD\n-\nX\n\n```\n\n# 入门篇\n\n``` mysql\ncreate table product(\n       p_name varchar2(20),              --oracle推荐使用varchar2可变字符长度\n       p_price number(4,2),              --number(总长度,小数长度)\n       p_time date,\n       p_category varchar2(5)\n);\n\n--添加列\nalter table product add (\n      p_weight number(4,2),\n      p_color varchar2(5)\n);\n\n--修改列类型\nalter table product modify p_weight varchar2(10);\n\nalter table product drop column p_weight;\n\ndrop table product;\n\ncreate table product(\n       p_id number primary key,   --设置主键约束\n       p_name varchar2(10) unique,             --设置唯一约束\n       p_time date not null,      --设置非空约束\n       p_category varchar(5) not null, --设置非空\n       p_color varchar2(6) check (p_color in (\'红\',\'黄\',\'蓝\')) --设置检查约束 \n);\n\ninsert into product values(1,\'柠檬茶\',current_date,\'饮料\',\'黄\');\ninsert into product values(2,\'鸡尾酒\',current_date,\'酒类\',\'蓝\');\ninsert into product values(3,\'西瓜汁\',current_date,\'甜品\',\'红\');\n\nselect * from product\n\n--外键关联表\ncreate table category(\n       c_id number primary key,\n       c_name varchar(10) not null\n);\n\ndelete from product\n\ninsert into category values(1,\'酒类\');\ninsert into category values(2,\'饮料\');\ninsert into category values(3,\'甜品\');\n\n--数字类型\nalter table product modify p_category number;\n\n--添加外键\nalter table product add foreign key(p_category) references category(c_id);\n\ninsert into product values(1,\'柠檬茶\',current_date,2,\'黄\');\ninsert into product values(2,\'鸡尾酒\',current_date,1,\'蓝\');\ninsert into product values(3,\'西瓜汁\',current_date,3,\'红\');\ninsert into product values(4,\'草莓圣代\',current_date,3,\'红\');\ninsert into product values(5,\'葡萄酒\',current_date,1,\'蓝\');\ninsert into product values(6,\'东鹏特饮\',current_date,2,\'黄\');\n\nselect * from product\nselect * from category\n\nselect p.p_name,c.c_name from product p\n       left join category c on p.p_category = c.c_id\n       where c.c_id = 3\n\n```\n\n# SpringBoot连接\n\n配置文件\n\n``` yml\nserver:\n  port: 8073\n\ndatabase:\n  oracle:\n    ip: 127.0.0.1\n    port: 1521\n    username: admin\n    password: admin16\n\nspring:\n  profiles:\n    active: dev\n  datasource:\n    driver-class-name: oracle.jdbc.driver.OracleDriver\n    url: jdbc:oracle:thin:@${database.oracle.ip}:${database.oracle.port}:orcl\n    username: ${database.oracle.username}\n    password: ${database.oracle.password}\n\nmybatis-plus:\n  global-config:\n    db-config:\n      capital-mode: true #字段大写\n      update-strategy: not_empty #非空串更新\n```\n\n## Jdbc\n\n``` java\n@Slf4j\n@Repository\npublic class ProductDao {\n\n    @Resource\n    private JdbcTemplate jdbcTemplate;\n\n    public List<ProductDto> findByType(int type) {\n        String querySQL = \"select p.*,c.c_name from product p\\n\" +\n                \"       left join category c on p.p_category = c.c_id\\n\" +\n                \"       where c.c_id = ?\";\n        //将数据的每一行对应字段封装成Product对象\n        RowMapper<ProductDto> rowMapper = new BeanPropertyRowMapper<>(ProductDto.class);\n        return jdbcTemplate.query(querySQL, new Object[] { type }, rowMapper);\n    }\n}\n```\n\n## MybatisPlus\n\n- Mapper\n\n``` java\npublic interface ProductMapper extends BaseMapper<Product> {\n\n    @Select(\"select p.*,c.c_name from product p\\n\" +\n            \"       left join category c on p.p_category = c.c_id\\n\" +\n            \"       where c.c_id = #{type}\")\n    List<ProductDto> CategoryOfProduct(@Param(\"type\") Integer type);\n}\n```\n\n- Service\n\n``` java\n@Slf4j\n@Service\npublic class ProductServiceImpl extends ServiceImpl<ProductMapper, Product> implements IProductService {\n\n    @Override\n    public List<ProductDto> getDrinkByType(Integer type) {\n        return super.baseMapper.CategoryOfProduct(type);\n    }\n}\n```\n\n[更详细的演示代码](https://github.com/AbrahamTemple/Oracle-Start)\n',NULL,0,0,0,NULL,'2021-01-01',358,'2021-01-01',15),
(63,25,'SpringBoot自动配置原理','http://8.135.100.252/image/2019-10-1/42754d4f-d611-49d3-a2bb-dd74c8594b45.jpg','微服务阶段    javase oop  mysql 持久化  html css js jQuery 框架 视图 框架运用不熟练 css不好  Javaweb 独立开发MVC三层架构的网站了 原始  ssm 框架 简化了我们的开发流程   ....','','#  **微服务阶段**\n\n![Alt text](http://8.135.100.252/image/2019-10-1/42754d4f-d611-49d3-a2bb-dd74c8594b45.jpg)\n\njavase：oop\n\nmysql:持久化\n\nhtml+css+js+jQuery+框架：视图 框架运用不熟练，css不好\n\nJavaweb：独立开发MVC三层架构的网站了：原始\n\nssm：框架：简化了我们的开发流程，配置也开始为复杂\n\n**war：tomcat运行**\n\nspring在简化：springboot-jar：内嵌tomcat，微服务架构！\n\n\n\n**高内聚，低耦合**\n\n\n\n# 第一个springboot\n\n​	到底多么简单\n\nspringboot：最新版\n\n\n\n官方提供了一个快速生成的网站！IDEA集成了这个网站\n\n\n\n\n\n更改端口号\n\n在application.properties中输入server.port=8081\n\n\n\n\n\n# 原理初探\n\n自动配置：\n\npom.xml\n\n- ```java\n  spring-boot-dependencies：核心依赖在父工程中\n  ```\n\n- 我们在写或者引入一些SpringBoot依赖的时候，不需要指定版本，就因为有这些版本仓库\n\n\n\n启动器\n\n- ```xml\n  <dependency>\n              <groupId>org.springframework.boot</groupId>\n              <artifactId>spring-boot-starter</artifactId>\n          </dependency>\n  ```\n\n- 启动器：说白了SpringBoot的启动场景；\n\n- 比如 spring-boot-starter-web，他就会自动帮我们导入web环境下的所有依赖！\n\n- Springboot会将所有的功能场景，都变成一个个启动器\n\n- 我们要使用什么功能，就需要找到对应的启动器就行了 `starter`\n\n\n\n**主程序：**\n\n```java\n//SpringBootApplication:标注这个类是一个SpringBoot应用\n@SpringBootApplication\npublic class Springboot01HellowordApplication {\n\n    public static void main(String[] args) {\n        //将SpringBoot应用启动\n        SpringApplication.run(Springboot01HellowordApplication.class, args);\n    }\n}\n```\n\n\n\n**注解**\n\n- ```java\n  @SpringBootConfiguration:SpringBootd的配置\n      	@Configuration：Spring配置类\n      	@Component：说明这也是一个Spring组件\n  \n  @EnableAutoConfiguration:自动配置\n      @AutoConfigurationPackage:自动配置包\n      @Import({AutoConfigurationImportSelector.class})\n  ```\n\n  - 获取候选的配置值\n\n    ```java\n     protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {\n            List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());\n            Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.\");\n            return configurations;\n        }\n    ```\n\nMETA-INF/spring.factories:自动配置的核心文件\n\n![1581844280055](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1581844280055.png)\n\n思考：这么多配置为什么有的没有生效，需要导入对应的start才能有作用。\n\n核心注解：@ConditionalOnxxx：如果这里面的条件都满足，才会生效\n\n\n\n结论：SpringBoot所有的自动配置都在启动类中被扫描并加载 `spring.factories` 所有的自动配置类都在这里面，但是不一定生效，要判断条件是否成立，只要导入了对应的start,就有对应的启动器，有了启动器我们自动装配就会生效，然后就配置成功了\n\n\n\n1. ​	SpringBoot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值；\n2. 将这些自动配置的导入容器，自动配置就会生效，帮我进行自动配置\n3. 以前我们需要配置的东西，现在Springboot帮我们做了！\n4. 整个JavaEE，解决方案和自动配置的东西都在spring-boot-autoconfigure-2.2.4.RELEASE.jar这个包下\n5. 它会把所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器；\n6. 容器中也会存在非常多的xxxxAutoConfiguration的文件，就是这些类给容器中导入了这个场景需要的 所有组件，并自动配置，@Configuration,JavaConfig\n7. 有了自动配置类，免去了我们手动编写配置文件的工作！\n\n\n\n\n\nJavaConfig		@Configuraion         	@Bean\n\n\n\nDocker:进程\n\n\n\n谈谈你对Springboot的理解\n\n- 自动装配\n- run（）\n\n\n\n全面接管SpringMVC的配置！实操\n\n\n\n# yaml\n\n==对空格的要求十分高==\n\n==可以注入到我们的配置类中==\n\nproperties只能存键值对\n\nyaml 可以存对象，数组\n\n​	**语法**：名称：空格名称\n\n![1582015722634](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1582015722634.png)\n\n\n\nyaml可以直接给我们的实体类赋值\n\n\n\n![1582020841540](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1582020841540.png)\n\n\n\n\n\n\n\n# JSR303验证\n\n需要在类上用上注解	**@Validated**\n\n ![img](https://upload-images.jianshu.io/upload_images/3145530-8ae74d19e6c65b4c?imageMogr2/auto-orient/strip|imageView2/2/format/webp) \n\n\n\n ![img](https://upload-images.jianshu.io/upload_images/3145530-10035c6af8e90a7c?imageMogr2/auto-orient/strip|imageView2/2/format/webp) \n\n\n\n# springboot配置原理\n\nyml配置文件到底能写什么？ 和spring.factories;\n\n在我们这样文件中存在的配置，都固有一个规律，xxxAutoConfiguration 默认值 xxxproperties 和配置文件绑定  我们就可以使用自定义配置。\n\n **@Conditional派生注解** \n\n​	作用： 必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效 \n\n![1584351424362](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1584351424362.png)\n\n\n\n**精髓**：\n\n1、SpringBoot启动会加载大量的自动配置类\n\n2、我们看我们需要的功能有没有在SpringBoot默认写好的自动配置类当中；\n\n3、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件存在在其中，我们就不需要再手动配置了）\n\n4、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们只需要在配置文件中指定这些属性的值即可；\n\n**xxxxAutoConfigurartion：自动配置类；**给容器中添加组件\n\n**xxxxProperties:封装配置文件中相关属性。**\n\n\n\n**debug=true**：\n\n​		那么多的自动配置类，必须在一定的条件下才能生效；也就是说，我们加载这么多的配置类，但不是所有的都生效了。\n\n​	我们怎么知道那些自动配置类生效？\n\n我们可以通过启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道那些自动类生效了。\n\n​	\n\n\n\n# SpringBootWeb开发\n\n\n\njar：webapp\n\n自动装配\n\nspringboot到底帮我们配置了什么？我们能不能进行修改？能修改那些东西？能不能扩展？\n\n- xxxAutoConfiguraion...向容器中自动配置组件\n- xxxxProperties  :自动配置类，装配配置文件中自定义的一些内容\n\n\n\n要解决的问题：\n\n- 导入静态资源...\n- 首页\n- .jsp,模板引擎Thymeleaf\n- 装配springmvc\n- 增删改查\n- 拦截器\n- 国际化！\n\n\n\n## 静态资源\n\n\n\n什么是webjars？\n\n通过源码总结：\n\n1. 在springboot，我们可以使用以下方式处理静态资源\n\n   ​	。webjars	 `localhost:8080/webjars/`\n\n   ​	。public，static，/**，resource		`localhost：8080/`\n\n2. 优先级：resources--->static:--->public\n\n\n\n\n\n## 模板引擎\n\n结论：只要使用thymeleaf，只需要导入对应的依赖即可使用，添加了依赖我们只需要把我们的html放在templates目录即可\n\n```java\npublic static final String DEFAULT_PREFIX = \"classpath:/templates/\";\npublic static final String DEFAULT_SUFFIX = \".html\";\n```\n\nAPI官网: https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#using-texts \n\nThymeleaf依赖\n\n```xml\n  <dependency>\n            <groupId>org.thymeleaf</groupId>\n            <artifactId>thymeleaf-spring5</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.thymeleaf.extras</groupId>\n            <artifactId>thymeleaf-extras-java8time</artifactId>\n        </dependency>\n```\n\n**yml里面去掉缓存:**\n\n```\nspring.thymeleaf.cache=false\n```\n\n## Mvc配置原理\n\n如果你想diy一些定制化功能，只要写这个组件，然后将他交给springboot，springboot讲会自动帮我们配置。\n\n自定义视图可以实现ViewResolver接口来帮我们实现自定视图\n\n\n\n在springboot中，有非常多的xxx Configuration 帮助我们扩展配置，只要看见这个东西，我们就应该注意了。\n\n\n\n1.首页配置：注意点，所有页面的静态资源都需要Thymeleaf接管；@{}\n\nurl: @{}\n\n2.页面国际化：注意点：\n\n​		1.我们需要配置i18n文件，\n\n​		2.我们如果需要在项目中进行按钮自动切换，我们需要自定义一个组件`LocaleResolver`\n\n​		3.记得将自己写的组件配置到	spring容器`@Bean`\n\n​		4.#{}\n\n3.登录+拦截器\n\n4.员工列表展示\n\n1. 提取公共页面\n   1.  `th:fragment=\"sidrbar\"`\n   2.  `th:replace=\"~{commons/commons::topbar}`\n   3.  如果要传递参数，可以直接使用（）传参，接收判断即可！\n2. ​	列表循环展示\n\n5.添加员工\n\n1. 按钮提交\n2. 跳转到添加页面\n3. 添加成功\n4. 返回首页\n\n6.CRUD\n\n7.404\n\n1. 直接在thymeleaf下建立一个error文件夹，然后把404.html和500.html放进去，它会帮我们自动识别\n\n8.如何写一个网站？\n\n前端：\n\n- 模板\n- 框架\n\n1. 前端搞定：页面长什么样子：数据\n\n2. 数据库设计（数据库设计难点！）\n\n3. 前端让他能够自动运行，独立化工程\n\n4. 数据接口如何对接：json  对象  all in one\n\n5. 前后端联调测试！\n\n6. 有一套自己熟悉的后台模板：工作必要！x-admin\n\n7. 前端页面：至少能够通过前u端框架，组合出来一个网站页面\n\n   ​					— index\n\n   ​					—  about\n\n   ​					—  blog\n\n   ​					— post \n\n   ​					— user\n\n8. 让这个网站运行起来！\n\n9. 一个月！\n\n\n\n## 这周内容\n\n1. JDBC\n2. Mybatis:重点\n3. Druid：重点\n4. Shiro:安全：重点\n5. spring security ：安全：重点\n6. 异步任务 ~，邮件发送，定时任务\n7. Swagger\n8. Dubbo+Zookeeper\n\n\n\n### Data\n\n今天先练习一下昨天讲的Config   Druid\n\n\n\n\n\n\n\n# Mybatis\n\nmybatis-spring-boot-starter\n\n\n\nM：数据和业务\n\nV：交换\n\nC：HTML\n\n1. 导入包\n\n2. 配置文件\n\n3. mybatis配置\n\n4. 编写是sql\n\n5. 业务层调用dao层\n\n6. controller调用service层\n\n   \n\n**@Repository：将mapper整合到spring里面**\n\n\n\n# springSecurity(安全)\n\n在web开发中，安全第一位！过滤器，拦截器~\n\n功能需求：否\n\n做网站：安全应该在什么时候考虑？\n\n- 漏洞：隐私泄露\n- 架构一旦确定~\n\nshiro、springSecurity：很像~除了类不一样，名字不一样\n\n认证、授权(vip1,vip2,vip3)\n\n\n\n- 功能权限\n- 访问权限\n- 菜单权限\n- ....拦截器 ，过滤器：大量的原生代码~繁琐 \n\n\n\nAOP:横切~配置类\n\n\n\n**简介**\n\nSpring Security是针对Spring项目的安全框架，也是SpringBoot底层安全模块的技术选型，他可以实现强大的Web安全控制，对于安全控制，我们仅需要引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理！\n\n记住这几个类：\n\n- WebSecurityConfigureAdapter：自定义Security策略\n- AuthenticationManagerBuilder：自定义认证策略\n- @EnableWebSecurity：开启WebSecurity模式，@Enablexxx开启某个功能\n\nSpring Security的两个主要目标是\"认证\"和\"授权\"(访问控制)。\n\n\"认证\":（Authentication）\n\n\"授权\"（Authorization）\n\n这个概念是通用的，而不是只在Spring Security中存在\n\n**config配置：**\n\n导入依赖：Security   ，thymeleaf-extras-springsecurity4\n\n```java\n@EnableWebSecurity\n//授权\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        super.configure(http);\n    }\n}\n```\n\n\n\n```java\n  //首页所有人都可以访问，功能页只有对应有权限的人可以访问\n        http.authorizeRequests()\n                .antMatchers(\"/\").permitAll()\n                .antMatchers(\"/level1/**\").hasAnyRole(\"vip1\")\n                .antMatchers(\"/level2/**\").hasAnyRole(\"vip2\")\n                .antMatchers(\"/level3/**\").hasAnyRole(\"vip2\");\n        //没有权限默认会到Login页面,需要开启到登录的页面\n        http.formLogin();\n```\n\n设置用户和密码：\n\n```java\n  	//认证  springboot2.1.x 可以直接使用\n	//密码编码：PasswordEncoder\n    //在spring security5.0新增加了很多的加密方法\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        //正常的话这些数据都应该从数据库中读\n        auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder())//密码编码，如果不设置可以被反射取出\n                .withUser(\"zhaoguoshun\").password(\"985211\").roles(\"vip2\")\n                .and()\n                .withUser(\"root\").password(\"985211\").roles(\"vip1,vip2,vip3\")\n                .and()\n                .withUser(\"yige\").password(\"985211\").roles(\"vip1\");\n    }\n```\n\n用户注销：\n\n​		在security中设置  http.logout，在前端设置点击注销，路径为logout\n\n记住我功能：\n\n​		http.rememberMe();//开启记住功能\n\ncsrf:\n\n​		http.csrf().disable();//关闭csrf  登录失败可能存在的原因\n\nloginPage(\"\")：自定义去自己的登录页面\n\nloginProcessingUrl(\"\")：提交登录地址  默认name是username 密码是pwd ，如果name和默认的不一样，需要设置 .usernameParameter和 .passwordParameter\n\n\n\n# Shiro\n\n1. 导入依赖\n2. 配置文件\n3. HelloWord\n\n\n\nSpring Security都有~\n\n```\nSubject currentUser = SecurityUtils.getSubject();\nSession session = currentUser.getSession();\ncurrentUser.isAuthenticated()\ncurrentUser.getPrincipal()\ncurrentUser.hasRole(\"schwartz\")\ncurrentUser.isPermitted(\"lightsaber:wield\")\ncurrentUser.logout();\n```\n\n\n\n## SpringBoot中集成\n\n需要编写Config：\n\n- ​	ShiroFilterFactoryBean  3.\n\n- DefaultWebSecurityManager  2.\n\n- 创建 Realm对象   ，可以自定义一个  1.\n\n  ```JAVA\n  @Bean\n      //ShiroFilterFactoryBean\n      public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n          ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n          //设置安全管理\n  \n          bean.setSecurityManager(defaultWebSecurityManager);\n          return bean;\n      }\n  \n      //DefaultWebSecurityManager\n      @Bean\n      public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\n          DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n          //关联UserRealm\n          securityManager.setRealm(userRealm);\n          return securityManager;\n      }\n  \n      @Bean\n      //创建 Realm对象   需要自定义类\n      public UserRealm userRealm(){\n          return  new UserRealm();\n      }\n  ```\n\n  //添加Shirod的内置过滤器\n\n  /** \n\n  ​        *anon:无需认证就可以访问 \n\n  ​        *authc:必须认证了才能访问 \n\n  ​        *user：必须拥有 记住我 功能才能用\n\n  ​        *perms:拥有对某个资源的权限才能访问 \n\n  ​         *role:拥有某个角色权限才能访问 \n\n  */\n\n再config自定义一个Realm对象：\n\n1. 继承 AuthorizingRealm\n\n2. 认证:\n\n   1. 在Controller中写入配置  form中填入login\n\n      ```java\n          @RequestMapping(\"/login\")\n          public String login(String username,String password,Model model){\n              //获取当前用户\n              Subject subject = SecurityUtils.getSubject();\n              //封装用户的登录数据\n              UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n               try{\n                   subject.login(token);//执行登录方法，如果没有异常就说明ok了\n                   return \"index\";\n               }catch (UnknownAccountException e){//用户名异常不存在\n                   model.addAttribute(\"msg\",\"用户名异常\");\n                   return \"login\";\n               }catch (IncorrectCredentialsException e){//密码异常\n                   model.addAttribute(\"msg\",\"密码异常\");\n                   return \"login\";\n              }\n          }\n      ```\n\n3. 配置密码需要再Realm认证中配置数据库密码\n\n   ```java\n   package com.zhaoguoshun.config;\n   \n   import org.apache.shiro.spring.web.ShiroFilterFactoryBean;\n   import org.apache.shiro.web.mgt.DefaultWebSecurityManager;\n   import org.springframework.beans.factory.annotation.Qualifier;\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.Configuration;\n   \n   import java.util.LinkedHashMap;\n   import java.util.Map;\n   \n   @Configuration\n   public class ShiroConfig {\n       @Bean\n       //ShiroFilterFactoryBean\n       public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Qualifier(\"getDefaultWebSecurityManager\") DefaultWebSecurityManager defaultWebSecurityManager){\n           ShiroFilterFactoryBean bean = new ShiroFilterFactoryBean();\n           //设置安全管理\n           bean.setSecurityManager(defaultWebSecurityManager);\n   \n           //添加Shirod的内置过滤器\n           /**\n            * anon:无需认证就可以访问\n            * authc:必须认证了才能访问\n            * user：必须拥有 记住我 功能才能用\n            * perms:拥有对某个资源的权限才能访问\n            * role:拥有某个角色权限才能访问\n            */\n           //filterMap.put(\"/user/add\",\"authc\");\n           //filterMap.put(\"/user/update\",\"authc\");\n           Map<String, String> filterMap =new LinkedHashMap<>();\n           //授权 ,正常的情况未授权会跳到未授权页面\n           filterMap.put(\"/user/add\",\"perms[user:add]\");\n           filterMap.put(\"/user/update\",\"perms[user:update]\");\n   \n           filterMap.put(\"/user/*\",\"authc\");\n   \n           bean.setLoginUrl(\"/toLogin\");\n           //设置未授权页面\n           bean.setUnauthorizedUrl(\"/noauth\");\n           bean.setFilterChainDefinitionMap(filterMap);\n           return bean;\n       }\n   \n       //DefaultWebSecurityManager\n       @Bean\n       public DefaultWebSecurityManager getDefaultWebSecurityManager(@Qualifier(\"userRealm\") UserRealm userRealm){\n           DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n           //关联UserRealm\n           securityManager.setRealm(userRealm);\n           return securityManager;\n       }\n   \n       @Bean\n       //创建 Realm对象   需要自定义类\n       public UserRealm userRealm(){\n           return  new UserRealm();\n       }\n   }\n   ```\n\n   ## Shiro整合Thymeleaf\n\n   1.导入依赖包：\n\n   ```xml\n   <dependency>\n               <groupId>com.github.theborakompanioni</groupId>\n            <artifactId>thymeleaf-extras-shiro</artifactId>\n               <version>2.0.0</version>\n        </dependency>\n   ```\n\n   2.在Config里面配置ShiroDialect：\n\n   ```java\n   @Bean\n       //ShiroDialect 来整个Shiro 和 Thymeleaf\n       public ShiroDialect getShiroDialect(){\n           return new ShiroDialect();\n       }\n   ```\n\n   3.在html 中导入命名空间\n\n   ```xml\n   xmlns:th=\"http://www.thymeleaf.org\"\n   ```\n\n   \n\n   # 任务\n\n   异步任务~\n\n   使用@Async注解,然后在我们开启类中加上@EnableAsync\n\n   定时任务~\n\n   邮件发送~\n\n   ```\n   host: smtp.qq.com\n    #开启加密验证\n    properties.mail.smtp.ssl.enble: true\n   ```\n\n   简单测试：\n\n   ```java\n    @Test\n       void contextLoads() {\n           //一个简单的邮件\n           SimpleMailMessage mailMessage = new SimpleMailMessage();\n           mailMessage.setSubject(\"赵国顺你好呀\");\n           mailMessage.setText(\"谢谢赵国顺全栈工程师的努力学习\");\n           //1107448323@qq.com\n           mailMessage.setTo(\"2274529540@qq.com\");\n           mailMessage.setFrom(\"2274529540@qq.com\");\n           mailSender.send(mailMessage);\n       }\n   ```\n\n   复杂测试：\n\n   ```java\n   @Test\n       void contextLoads2() throws MessagingException {\n           //一个复杂的邮件\n           MimeMessage mimeMailMessage=mailSender.createMimeMessage();\n           //组装\n           MimeMessageHelper helper=new MimeMessageHelper(mimeMailMessage,true);\n           //附件\n           helper.setSubject(\"赵国顺你好呀\");\n           helper.setText(\"<p style=\'color:red\'>谢谢赵国顺全栈工程师的努力学习</p>\",true);\n           helper.addAttachment(\"1.jpg\",new File(\"D:\\\\a\\\\1.jpg\"));\n           helper.addAttachment(\"2.jpg\",new File(\"D:\\\\a\\\\1.jpg\"));\n           helper.setTo(\"2274529540@qq.com\");\n           helper.setFrom(\"2274529540@qq.com\");\n           mailSender.send(mimeMailMessage);\n       }\n   ```\n\n   \n\n   \n\n   yml配置信息\n\n   ```yml\n   spring:\n     mail:\n       username: 2274529540@qq.com\n       password: eduntyolanzadieb\n       host: smtp.qq.com\n       #开启加密验证\n       properties.mail.smtp.ssl.enble: true\n   \n   ```\n\n   \n\n   ​		\n\n   ```\n   TaskScheduler	任务调度者\n   TaskExecutor	任务执行者\n   \n   @EnableScheduling //开启定时功能的注解\n   @Scheduled //什么时候执行\n   \n   cron 表达式\n   ```\n\n   \n\n   \n\n   ## 小结知识点\n\n   \n\n   使用jpa可以在实体类（pojo）中快速生成数据库表结构。\n\n   1.导入依赖：\n\n   ```xml\n    <dependency>\n               <groupId>org.springframework.boot</groupId>\n               <artifactId>spring-boot-starter-data-jpa</artifactId>\n               <version>2.2.4.RELEASE</version>\n           </dependency>\n   \n   \n   可以在yml里这样配置：\n   jpa:\n       hibernate:\n         ddl-auto: update\n       show-sql: true\n   ```\n\n   \n\n   2.在实体类上加上 ：@Entity，和Table(\"表的名字\")。\n\n   3.需要指定id，在id上面加上:@Id，和@GeneratedValue注解。\n\n   \n\n   4.如果是Date，需要在变量上面加上：@Temporal(TemporalType.TIMESTAMP)\n\n   注意：实体类会报错，是因为idea没有检测出来，直接运行就会生成表，并不影响其他。\n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   \n\n   ​		',NULL,0,0,0,NULL,'2021-01-01',353,'2021-01-01',17),
(64,41,'Linux实用命令简集','http://8.135.100.252/image/2019-10-1/e3590721-28a6-4cf8-ae78-8129794cb0d7.jpg','\\  Vue    HTML CSS JS  视图   给用户看 刷新后台的数据     网络通信 axios    页面跳转 vue-router    状态管理 vuex    MVVM model-view-view-model     HTML先加载js     \\   xml    \\                v-bind   \"\"        \\   v-if v-else  ','','[[toc]]\n\n# Linux命令\n\n## 查看磁盘内存占用最多的\n\n``` shell\n[root@hecs-x-medium-2-linux-20210511093644 docker]# df -h\nFilesystem      Size  Used Avail Use% Mounted on\ndevtmpfs        909M     0  909M   0% /dev\ntmpfs           919M   40K  919M   1% /dev/shm\ntmpfs           919M   68M  852M   8% /run\ntmpfs           919M     0  919M   0% /sys/fs/cgroup\n/dev/vda1        40G   40G     0 100% /\ntmpfs           184M     0  184M   0% /run/user/0\noverlay          40G   40G     0 100% /var/lib/docker/overlay2/8320a8c2f3d1fcd10c1221c9fe8f9c4e18494aaffea800937c3d9f4223edd79c/merged\noverlay          40G   40G     0 100% /var/lib/docker/overlay2/ad794b437d2fa7f25afc99d365cb2d06bfad1a18fac1b1d733273db6a16c4d25/merged\noverlay          40G   40G     0 100% /var/lib/docker/overlay2/c165d1c50cff77e4477b7b74de757152e77873959753d977aea1237d7e763fe8/merged\noverlay          40G   40G     0 100% /var/lib/docker/overlay2/fb1221a558566bb547fa19d060f6049b0c4a821555b69a8043f598f97379f2eb/merged\n[root@hecs-x-medium-2-linux-20210511093644 overlay2]# rm -fr *\n```\n\n``` shell\n[root@hecs-x-medium-2-linux-20210511093644 dev]# find / -type f -size +10G\n/proc/kcore\nfind: ‘/proc/10645/task/10645/fdinfo/6’: No such file or directory\nfind: ‘/proc/10645/fdinfo/5’: No such file or directory\n/www/docker/olife-base/log.file\n```\n\n## 查看运行内存占用最多的10条\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ local]# ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head\n```\n\n## 通过pid查端口\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ local]# netstat -nap | grep 29141\n```\n\n## 通过pid查路径\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ docker]# pwdx 1293\n1293: /var/lib/rabbitmq\n```\n\n## 查看指定端口占用情况并将其杀掉\n\n``` shell\n[root@hecs-x-medium-2-linux-20210511093644 bin]# lsof -i:8848\nCOMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\njava    3488 root   95u  IPv6 672520      0t0  TCP *:8848 (LISTEN)\njava    3488 root  103u  IPv6 672525      0t0  TCP hecs-x-medium-2-linux-20210511093644:8848->hecs-x-medium-2-linux-20210511093644:34726 (ESTABLISHED)\njava    3488 root  104u  IPv6 672526      0t0  TCP hecs-x-medium-2-linux-20210511093644:34726->hecs-x-medium-2-linux-20210511093644:8848 (ESTABLISHED)\n[root@hecs-x-medium-2-linux-20210511093644 bin]# kill 3488\n```\n\n## 查看指定端口进程情况\n\n``` shell\n[root@hecs-x-medium-2-linux-20210511093644 bin]# netstat -tunlp |grep 3306\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      19774/mysqld   \n```\n\n## 按进程名搜索该进程占用情况\n\n``` shell\n[root@hecs-x-medium-2-linux-20210511093644 bin]# ps -ef|grep mysql\nroot      3973  2288  0 15:23 pts/0    00:00:00 grep --color=auto mysql\npolkitd  13722 13702  0 May18 ?        00:02:52 mysqld\nroot     13840 13831  0 May18 pts/0    00:00:00 mysql -uroot -px x\npolkitd  14035 14015  0 May18 ?        00:02:48 mysqld\nroot     14156 14148  0 May18 pts/0    00:00:00 mysql -uroot -px x\nroot     19207     1  0 May13 ?        00:00:00 /bin/sh /www/server/mysql/bin/mysqld_safe --datadir=/www/server/data --pid-file=/www/server/data/hecs-x-medium-2-linux-20210511093644.pid --sql-mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\nmysql    19774 19207  0 May13 ?        00:04:11 /www/server/mysql/bin/mysqld --basedir=/www/server/mysql --datadir=/www/server/data --plugin-dir=/www/server/mysql/lib/plugin --user=mysql --sql-mode=NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION --log-error=hecs-x-medium-2-linux-20210511093644.err --open-files-limit=65535 --pid-file=/www/server/data/hecs-x-medium-2-linux-20210511093644.pid --socket=/tmp/mysql.sock --port=3306\n```\n\n## 查询防火墙是否开启指定端口并开放与重载\n\n``` shell\n[root@hecs-x-medium-2-linux-20210511093644 bin]# systemctl status firewalld\n● firewalld.service - firewalld - dynamic firewall daemon\n   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; enabled; vendor preset: enabled)\n   Active: active (running) since Thu 2021-05-13 02:08:06 CST; 1 weeks 3 days ago\n     Docs: man:firewalld(1)\n Main PID: 27395 (firewalld)\n    Tasks: 2\n   Memory: 27.3M\n   CGroup: /system.slice/firewalld.service\n           └─27395 /usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid\n[root@hecs-x-medium-2-linux-20210511093644 bin]# firewall-cmd --query-port=8848/tcp\nno\n[root@hecs-x-medium-2-linux-20210511093644 bin]# firewall-cmd --add-port=8848/tcp --permanent\nsuccess\n[root@hecs-x-medium-2-linux-20210511093644 bin]# firewall-cmd --reload\nsuccess\n[root@hecs-x-medium-2-linux-20210511093644 bin]# firewall-cmd --query-port=8848/tcp\nyes\n```\n\n## 查看倒数行日志\n\n``` shell\n[root@abraham-cloud ~]# cd /var/lib/docker/containers\n[root@abraham-cloud containers]# ls\n142ecd80909c547e52d3aca9417f2d908bcdf7dc2901b21cbdd7dbb435885664  5e30236afd7143019d59f96b610e0dced322d9fdb8d58595d93e88711973bc61\n23c1a625e12b3770fdb4a090e567357dfa70074fa749a48b15e9f7aba2f6f333  ef0880dd023427ad51cebcd1d26f76bad1f92a5a79345d7831c897766d1892b3\n305d3a9035877c578c66e9a9d5653d442654b7a5523cd503993f387726f1431a\n[root@abraham-cloud 305d3a9035877c578c66e9a9d5653d442654b7a5523cd503993f387726f1431a]# tail -n 200 305d3a9035877-json.log\n```\n',NULL,0,0,0,NULL,'2021-01-01',353,'2021-01-01',17),
(65,19,'Go语言入门','http://8.135.100.252/image/2019-10-1/3209c98c-d1ca-43c3-9c18-9f5a314551a7.jpg','Go 具有表现力、简洁、干净和高效。它的并发机制可以轻松编写程序，充分利用多核和联网机器，而其新颖的类型系统可以实现灵活和模块化的程序构建。Go 可以快速编译为机器代码，但具有垃圾收集的便利性和运行时反射的能力。它是一种快速、静态类型的编译语言，感觉就像是一种动态类型的解释型语言。','','![Alt text](http://8.135.100.252/image/2019-10-1/3209c98c-d1ca-43c3-9c18-9f5a314551a7.jpg)\n[[toc]]\n\n# golang入门基础\n\n## 变量声明及使用\n\n``` go\npackage main\n\nimport \"fmt\"\n\n/**\n变量声明及使用\n */\n\nfunc main()  {\n	var a int //默认是0\n	fmt.Print(\"a = \", a)\n	fmt.Printf(\" type of a = %T\\n\", a)\n	var b int = 100 //初始化\n	fmt.Print(\"b = \", b)\n	fmt.Printf(\" type of b = %T\\n\", b)\n	var c  = 0.01 //自动匹配类型初始化\n	fmt.Print(\"c = \", c)\n	fmt.Printf(\" type of c = %T\\n\", c)\n	d := \"123\" //省去var，自动匹配\n	fmt.Print(\"d = \", d)\n	fmt.Printf(\" type of d = %T\\n\", d)\n	/* ---多声明--- */\n	var aa,bb int = -1, 0\n	fmt.Printf(\" type of aa = %T\\n\", aa)\n	fmt.Printf(\" type of bb = %T\\n\", bb)\n\n}\n```\n\n## 常量声明及使用\n\n``` go\npackage main\n\nimport \"fmt\"\n\n/**\n常量声明及使用\n */\n\nconst(\n	//iota关键字以下的会累计加5，默认是0(BEGIN)\n	BEGIN = 5*iota\n	ONE\n	TWO\n)\n\nconst(\n	//iota关键字以下的会累计加1，默认是0(BEGIN)\n	BEGINS = 5+iota\n	ONCE\n	TWICE\n)\n\nfunc main(){\n	const len int = 10 //常量只可读\n	fmt.Print(\"length = \",len)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"BEGIN = \",BEGIN)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"ONE = \",ONE)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"TWO = \",TWO)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"BEGINS = \",BEGINS)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"ONCE = \",ONE)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"TWICE = \",TWICE)\n}\n```\n\n## 方法声明及使用\n\n``` go\npackage main\n\nimport \"fmt\"\n\n/**\n方法声明及使用\n */\n\n//单返回值\nfunc foo(a string,b int) int {\n	fmt.Print(\"a = \",a)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"b = \",b)\n	fmt.Print(\"\\n\")\n	c := b+6\n	return c\n}\n\n//多返回值匿名\nfunc foo2(a string,b int) (int,int) {\n	fmt.Print(\"a = \",a)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"b = \",b)\n	fmt.Print(\"\\n\")\n	c := b*6\n	return b,c\n}\n\n//多返回值署名\nfunc foo3(a string,b int) (r1 int,r2 int) {\n	fmt.Print(\"a = \",a)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"r1 = \",r1)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"r2 = \",r2)\n	fmt.Print(\"\\n\")\n\n	r1 = b*6+6\n	r2 = b*6-6\n\n	return\n}\n\n//同类型合并返回值署名\nfunc foo4(a string,b int) (r1 ,r2 int) {\n	fmt.Print(\"a = \",a)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"r1 = \",r1)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"r2 = \",r2)\n	fmt.Print(\"\\n\")\n\n	r1 = b*8+8\n	r2 = b*8-8\n\n	return\n}\n\nfunc main() {\n	c := foo(\"单返回值\",2)\n	fmt.Print(\"c1 = \",c)\n	fmt.Print(\"\\n\")\n\n	b, c := foo2(\"多返回值匿名\", 2)\n	fmt.Print(\"b2 = \",b)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"c2 = \",c)\n	fmt.Print(\"\\n\")\n\n	b, c = foo3(\"多返回值署名\", 2)\n	fmt.Print(\"b3 = \",b)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"c3 = \",c)\n	fmt.Print(\"\\n\")\n\n	b, c = foo4(\"同类型合并返回值署名\", 2)\n	fmt.Print(\"b3 = \",b)\n	fmt.Print(\"\\n\")\n	fmt.Print(\"c3 = \",c)\n	fmt.Print(\"\\n\")\n}\n```\n\n## init与导包\n\n- /main.go \n\n``` go\npackage main\n\n/**\ninit与导包\n */\n\n// 请将GO111MODULE设为自动: go env -w GO111MODULE=auto\n\nimport (\n	\"../chapter5/lib1\"\n	\"../chapter5/lib2\"\n)\n\nfunc main()  {\n	// 所有人的init会最先被执行完\n	lib1.TestLib()\n	lib2.TestLib()\n}\n```\n\n- /lib1/lib1.go\n\n``` go\npackage lib1\n\nimport \"fmt\"\n\n//首字母大写才会暴露\nfunc TestLib()  {\n	fmt.Println(\"lib1包的方法被调用\")\n}\n\nfunc init() {\n	fmt.Println(\"lib1包的init被调用\")\n}\n```\n\nlib2也亦如此\n\n## 匿名与别名导包\n\n``` go\npackage main\n\n/**\n匿名与别名导包\n */\n\nimport (\n	_ \"../chapter5/lib1\" // 匿名：虽然只调用不使用，但init依旧会被执行\n	pkg2 \"../chapter5/lib2\" // 别名：把包里所有内容赋给pkg2\n	. \"../chapter5/lib2\" // 别名：把包里所有内容导入当前包，直接引用即可\n)\n\nfunc main() {\n	pkg2.TestLib()\n	TestLib()\n}\n```\n\n## 指针\n\n```go\npackage main\n\nimport \"fmt\"\n/**\n指针\n */\n\n// 指针就是地址，地址就是指针\n// &代表地址，*代表地址数据结构，**代表地址的地址的数据结构（上一层必须是地址）\n\nfunc main() {\n	var a int = 1\n	change1(a) //这时的指针指针指向形参的地址，没能改变a原内存里的值\n	fmt.Println(a)\n	change2(&a) //让指针指向原内存地址，并且改变内存里的值\n	fmt.Println(a)\n\n	var b  = 2\n	switches(&a,&b) //互换a和b的值\n	fmt.Println(\"a =\",a,\"b =\",b)\n\n	var pa *int\n	pa = &a //a的地址赋给pa数据结构\n	fmt.Println(pa)\n\n	var ppa  ** int //二层地址\n	ppa = &pa //pa数据结构的地址赋给ppa数据结构\n\n	fmt.Println(ppa)\n}\n\nfunc change1(p int)  {\n	p = 10\n}\n\nfunc change2(p *int)  {\n	*p = 10\n}\n\nfunc switches(a *int, b *int)  {\n	var t int\n	t = *b //b原内存值给t\n	*b = *a //a原内存值给b\n	*a = t //b值给a作为原内存值\n}\n\n```\n\n## defer\n\n``` go\npackage main\n\nimport \"fmt\"\n\n/**\n反序执行\n */\n\n// 再怎么样，return关键字都比defer关键字更后执行\n\nfunc process1()  {\n	fmt.Println(\"---1号程序被执行---\")\n}\n\nfunc process2()  {\n	fmt.Println(\"---2号程序被执行---\")\n}\n\nfunc process3() string {\n	defer process1()\n	defer process2()\n	return \"---3号程序被执行---\"\n}\n\nfunc main() {\n	//defer: 程序是从上往下先后执行变成从下往上先后执行\n	defer process1()\n	defer process2()\n	fmt.Println(process3())\n}\n```\n\n## 数组声明与循环\n\n``` go\npackage main\n\nimport (\n	\"fmt\"\n)\n\n/**\n数组声明与循环\n */\n\nfunc main() {\n	var arr1 [2]int //默认值为0\n\n	arr2 := [5]int{1,2,3} //不填充部分默认值为0\n\n	arr3 := []float32{0.1,0.2,0.3} //动态长度\n\n	x,y := 1, 2\n\n	arr4 := [...]*int{&x,&y} //指针数组\n\n	var arr5 = [...]int{1:\'a\',2:\'b\'} //字符自动转义成数字\n\n	fmt.Println(\"第一类循环，arr1\") //自动匹配长度\n	for i := range arr1 {\n		fmt.Println(\"value =\" ,arr1[i])\n	}\n\n	fmt.Println(\"第二类循环，arr2\") //附带index\n	for index, value := range arr2 {\n		fmt.Println(\"index =\" ,index,\"value =\" ,value)\n	}\n\n	fmt.Println(\"第三类循环，arr3\") //index匿名\n	for _, value := range arr3 {\n		fmt.Println(\"value =\" ,value)\n	}\n\n\n	change(&x,&y)\n	//doForArray(&arr4)\n	//fmt.Println(\"默认循环，arr4\")\n	//for i := 0; i< len(arr4); i++ {\n	//	fmt.Println(\"index =\" ,i,\"value =\" ,arr4[i])\n	//}\n\n	fmt.Println(\"默认循环，arr4\")\n	for i := 0; i< len(arr4); i++ {\n		fmt.Println(\"index =\" ,i,\"address =\" ,arr4[i],\"value =\",*arr4[i])\n	}\n\n	fmt.Println(\"第二类循环，arr5\") //0号位没初始化，则值为0\n	for index, value := range arr5 {\n		fmt.Println(\"index =\" ,index,\"value =\" ,value)\n	}\n}\n\nfunc change(px *int,py *int)  {\n	*px = 25\n	*py = 36\n}\n\nfunc doForArray(arr *[]int) {\n\n	//指针数组\n	for index, value := range *arr {\n		fmt.Println(\"index =\" ,index,\"value =\" ,value)\n	}\n\n}\n\n```\n\n## 切片\n\n``` go\npackage main\n\nimport \"fmt\"\n\n/**\n数组切片\n */\n\nfunc main() {\n	var arr []int\n	fmt.Println(arr,\"数组是否为空:\",arr==nil) //数组为空，存储任何下标位都会报错\n	arr = make([]int,3) //初始化出3个位置值为0的int数组\n	fmt.Println(arr,\"数组是否为空:\",arr==nil)\n\n	nums := make([]int,2,4) //2个位置，4个容量(容量不是长度，而是追加限度)\n	fmt.Println(\"长度:\", len(nums),\"容量:\",cap(nums),\"数组:\",nums)\n\n	nums = append(nums, 1)//追加1个1\n	fmt.Println(\"长度:\", len(nums),\"容量:\",cap(nums),\"数组:\",nums)\n\n	nums = append(nums, 2)//追加一个2，此时容量已达到定义的极限\n	fmt.Println(\"长度:\", len(nums),\"容量:\",cap(nums),\"数组:\",nums)\n\n	nums = append(nums, 3)//追加一个3，开辟新的4个容量跟原来的4容器合并\n	fmt.Println(\"长度:\", len(nums),\"容量:\",cap(nums),\"数组:\",nums)\n\n\n	fmt.Println(\"nums切片:\",nums[2:5])\n\n	ns := nums //ns和nums都指向同一个地址\n	ns[3] = 0\n\n	fmt.Println(\"ns切片:\",ns[2:5])\n	fmt.Println(\"nums切片:\",nums[2:5])\n\n	ns2 := make([]int,len(nums),cap(nums))\n	copy(ns2,nums) //将nums拷贝到ns，ns用新的地址\n\n	ns2[3] = 8\n	fmt.Println(\"ns2切片:\",ns2[2:5])\n	fmt.Println(\"nums切片:\",nums[2:5])\n}\n\n```\n\n## 类型强制转换\n\n``` go\npackage main\n\nimport \"strconv\"\nimport \"fmt\"\n\n/**\n类型强制转换\n */\n\nconst (\n	str = \"6\"\n	num = 8\n)\n\nfunc main() {\n\n	//string转成int：\n	strnum, err1 := strconv.Atoi(str)\n	fmt.Println(\"string转成int=\",strnum,\"异常\",err1)\n	//string转成int64：\n	strnum64, err2 := strconv.ParseInt(str, 10, 64)\n	fmt.Println(\"string转成int64=\",strnum64,\"异常\",err2)\n	//int转成string：\n	numstr := strconv.Itoa(num)\n	fmt.Println(\"int转成string=\",numstr)\n\n	//int转化为int64\n	int64num := int64(num)\n\n	//int64转成string：\n	num64str := strconv.FormatInt(int64num,10)\n	fmt.Println(\"int64转成string=\",num64str)\n}\n\n```\n\n## map声明应用\n\n``` go\npackage main\n\nimport \"fmt\"\n/**\nmap声明应用\n */\nfunc main() {\n\n	//------- 声明 -----------\n	var m map[string] string\n\n	b := map[bool] string{m==nil:\"指针为空\",m!=nil:\"指针不为空\"}[true]\n	fmt.Println(b)\n\n	//分配10容量\n	m = make(map[string] string, 10)\n\n	b = map[bool] string{m==nil:\"指针为空\",m!=nil:\"指针不为空\"}[true]\n	fmt.Println(b)\n\n	m[\"A\"] = \"java\"\n	m[\"B\"] = \"go\"\n	m[\"C\"] = \"c++\"\n\n	fmt.Println(m)\n\n	//分配可变容量\n	m1 := make(map[int] string)\n\n	m1[0] = \"java\"\n	m1[1] = \"go\"\n	m1[2] = \"c++\"\n\n	fmt.Println(m1)\n\n	//声明并赋值\n	m2 := map[string] string{\n		\"one\": \"java\",\n		\"two\": \"go\",\n	}\n\n	fmt.Println(m2)\n\n\n	//------- 应用 -----------\n	delete(m2,\"one\") //删除map指定key\n\n	for k, v := range m2 {\n		fmt.Println(\"k=\",k,\"v=\",v)\n	}\n}\n\n```\n\n## 继承\n\n``` go\npackage main\n\nimport \"fmt\"\n\n/**\n继承\n */\n\ntype Animal struct {\n	name string\n	shout string\n}\n\nfunc (this *Animal) setShout(shout string) {\n	this.shout = shout\n}\n\nfunc (this Animal) getShout() string {\n	return this.shout\n}\n\ntype Dog struct {\n	Animal //代表继承\n}\n\nfunc (this *Dog) setShout(shout string) {\n	this.shout = shout\n}\n\ntype Cat struct {\n	Animal //代表继承\n}\n\nfunc (this *Cat) setShout(shout string) {\n	this.shout = shout\n}\n\nfunc main() {\n	dog := Dog{Animal{name:\"史努比\",shout:\"汪汪汪\"}}\n	fmt.Println(dog.shout)\n\n	cat := Cat{Animal{name:\"加菲猫\",shout:\"喵喵喵\"}}\n	fmt.Println(cat.shout)\n}\n\n```\n\n## 结构体\n\n``` go\npackage main\n\nimport \"fmt\"\n\n/**\n结构体\n */\n\n//方法或结构体如果是大写则代表public\n//方法或结构体如果是小写则代表private\ntype User struct {\n	id int\n	name string\n}\n\nfunc (this User) getName() string {\n	return this.name\n}\n\nfunc (this *User) setName(name string) {\n	this.name = name\n}\n\nfunc main() {\n	var u User\n	u.id = 1\n	u.name = \"张三\"\n\n	fmt.Printf(\"%v\\n\",u)\n\n	change(&u,0,\"李四\")\n\n	fmt.Printf(\"%v\\n\",u)\n\n	//---------实际用法----------\n	u2 := User{id:2,name:\"哈哈\"}\n	u2.setName(\"王五\")\n	fmt.Println(u2.getName())\n}\n\nfunc change(user *User,id int,name string){\n	user.id = id\n	user.name = name\n}\n\n```\n\n[更多源码请访问这里](https://github.com/AbrahamTemple/Go-Learn)',NULL,0,0,0,NULL,'2021-01-01',357,'2021-01-01',17),
(66,43,'MySQL优化','http://8.135.100.252/image/2019-10-1/052a98cd-4c31-4049-a0fd-cf1837265db8.jpg','SQL优化是定位有问题的语句，检查执行计划，检查执行过程中优化器的统计信息，分析相关表的记录数、索引情况改写SQL语句、使用HINT、调整索引、表分析有些SQL语句不具备优化的可能，需要优化处理方式达到最佳执行计划。','','![Alt text](http://8.135.100.252/image/2019-10-1/052a98cd-4c31-4049-a0fd-cf1837265db8.jpg)\n[[toc]]\n\n# Sql执行顺序 \n  \n``` sql\n(8) SELECT(9) DISTINCT column,…\n选择字段 、去重\n\n(6) AGG_FUNC(column or expression),…\n聚合函数\n\n(1) FROM [left_table]\n选择表\n\n(3) <join_type> JOIN <right_table>\n链接\n\n(2) ON <join_condition>\n链接条件\n\n(4) WHERE <where_condition>\n条件过滤\n\n(5) GROUP BY <group_by_list>\n分组\n\n(7) HAVING <having_condition>\n分组过滤\n\n(10) ORDER BY <order_by_list>\n排序\n\n(11) LIMIT count OFFSET count;\n分页\n``` \n\n # 基础Sql优化 \n ## 查询SQL尽量不要使用select *，而是具体字段 \n  \n```sql\nSELECT * FROM student\n```\n \n  \n```sql\nSELECT id,NAME FROM student\n```\n \n  \n - 字段多时，大表能达到100多个字段甚至达200多个字段\n- 只取需要的字段，节省资源、减少网络开销\n- select * 进行查询时，很可能不会用到索引，就会造成全表扫描\n \n ## 避免在where子句中使用or来连接条件 \n  \n  \n```sql\nSELECT * FROM student WHERE id=<span class=\"token number\">1 OR salary=<span class=\"token number\">30000\n```\n \n  \n```sql\nSELECT * FROM student WHERE id=<span class=\"token number\">1\nUNION ALL\nSELECT * FROM student WHERE salary=<span class=\"token number\">30000\n```\n \n  \n```sql\nSELECT * FROM student WHERE id=<span class=\"token number\">1\nSELECT * FROM student WHERE salary=<span class=\"token number\">30000\n```\n \n  \n - 使用or可能会使索引失效，从而全表扫描\n- 对于or没有索引的salary这种情况，假设它走了id的索引，但是走到salary查询条件时，它还得全表扫描。也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定。虽然mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引还是可能失效的\n \n ## 使用varchar代替char \n  \n```sql\n`deptname` char(<span class=\"token number\">100) DEFAULT <span class=\"token boolean\">NULL COMMENT  \'部门名称\'\n```\n \n  \n```sql\n`deptname` varchar(<span class=\"token number\">100) DEFAULT <span class=\"token boolean\">NULL COMMENT  \'部门名称\'\n```\n \n  \n - varchar变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间\n- char按声明大小存储，不足补空格\n- 其次对于查询来说，在一个相对较小的字段内搜索，效率更高\n \n ## 尽量使用数值替代字符串类型 \n - <strong>主键（id）</strong>：primary key优先使用数值类型int，tinyint\n- <strong>性别（sex）</strong>：0-代表女，1-代表男；数据库没有布尔类型，mysql推荐使用tinyint\n- <strong>支付方式（payment）</strong>：1-现金、2-微信、3-支付宝、4-信用卡、5-银行卡\n- <strong>服务状态（state）</strong>：1-开启、2-暂停、3-停止\n- <strong>商品状态（state）</strong>：1-上架、2-下架、3-删除\n \n ## 查询尽量避免返回大量数据 \n  \n ## 使用explain分析你SQL执行计划 \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE id=<span class=\"token number\">1\n```\n \n  \n ## 是否使用了索引及其扫描类型 \n  \n  \n - <mark>ALL</mark> 全表扫描，没有优化，最慢的方式\n- <mark>index</mark> 索引全扫描\n- <mark>range</mark> 索引范围扫描，常用语&lt;，&lt;=，>=，between等操作\n- <mark>ref</mark> 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中\n- <mark>eq_ref</mark> 类似ref，区别在于使用的是唯一索引，使用主键的关联查询\n- <mark>const</mark> 当查询是对主键或者唯一键进行精确查询，系统会把匹配行中的其他列作为常数处理\n- <mark>null MySQL</mark>不访问任何表或索引，直接返回结果\n- <mark>System</mark> 表只有一条记录(实际中基本不存在这个情况)\n \n <blockquote>\n\n</blockquote> \n  \n - 显示可能应用在这张表中的索引\n \n  \n - 真正使用的索引方式\n \n ## 创建name字段的索引 \n  \n```sql\nALTER TABLE student ADD INDEX index_name (NAME)\n```\n \n ## 优化like语句： \n  \n  \n```sql\nEXPLAIN\nSELECT id,NAME FROM student WHERE NAME LIKE  \'%1\'\nEXPLAIN\nSELECT id,NAME FROM student WHERE NAME LIKE  \'%1%\'\n```\n \n  \n```sql\nEXPLAIN\nSELECT id,NAME FROM student WHERE NAME LIKE  \'1%\'\n```\n \n  \n```sql\nEXPLAIN\nSELECT id,NAME FROM student WHERE NAME=<span class=\"token number\">1 OR sex=<span class=\"token number\">1\n```\n \n  \n  \n```sql\nEXPLAIN\nSELECT id,NAME FROM student WHERE id=<span class=\"token number\">1\n```\n \n  \n  \n```sql\nEXPLAIN\nSELECT id,NAME FROM student WHERE id LIKE  \'%1\'\n```\n \n  \n ## 字符串怪现象 \n  \n```sql\n#未使用索引\nEXPLAIN\nSELECT * FROM student WHERE NAME=<span class=\"token number\">123\n```\n \n  \n```sql\n#使用索引\nEXPLAIN\nSELECT * FROM student WHERE NAME= \'123\'\n```\n \n  \n - 为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为数值类型再做比较\n \n ## 索引不宜太多，一般5个以内 \n - 索引并不是越多越好，虽其提高了查询的效率，但却会降低插入和更新的效率\n- 索引可以理解为一个就是一张表，其可以存储数据，其数据就要占空间\n- 再者，索引表的一个特点，其数据是排序的，那排序要不要花时间呢？肯定要\n- insert或update时有可能会重建索引，如果数据量巨大，重建将进行记录的重新排序，所以建索引需要慎重考虑，视具体情况来定\n- 一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否有存在的必要\n \n ## 索引不适合建在有大量重复数据的字段上 \n  \n ## where限定查询的数据 \n  \n  \n```sql\nSELECT id,NAME FROM student WHERE sex= \'男\'\n```\n \n  \n```sql\nSELECT id,NAME FROM student WHERE id=<span class=\"token number\">1 AND sex= \'男\'\n```\n \n  \n - 需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销\n \n ## 避免在索引列上使用内置函数 \n  \n  \n```sql\nALTER TABLE student ADD INDEX idx_birthday (birthday)\n```\n \n  \n```sql\nSELECT NOW()	\nSELECT DATE_ADD(NOW(), INTERVAL <span class=\"token number\">7 DAY)\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student\nWHERE DATE_ADD(birthday,INTERVAL <span class=\"token number\">7 DAY) >=NOW();\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student\nWHERE  birthday >= DATE_ADD(NOW(),INTERVAL <span class=\"token number\">7 DAY);\n```\n \n  \n  \n \n ## 避免在where中对字段进行表达式操作 \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE id+<span class=\"token number\">1-<span class=\"token number\">1=+<span class=\"token number\">1\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE id=+<span class=\"token number\">1-<span class=\"token number\">1+<span class=\"token number\">1\n```\n \n```sql\nEXPLAIN\nSELECT * FROM student WHERE id=<span class=\"token number\">1\n```\n \n  \n - SQL解析时，如果字段相关的是表达式就进行全表扫描\n \n  \n - 字段干净无表达式，索引生效<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/20210409162421235.png\"/>\n \n ## 避免在where子句中使用!=或&lt;>操作符 \n  \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE salary!=<span class=\"token number\">3000\n```\n \n```sql\nEXPLAIN\nSELECT * FROM student WHERE salary&lt;><span class=\"token number\">3000\n```\n \n  \n - 使用!=和&lt;>很可能会让索引失效<br/> <img alt=\"在这里插入图片描述\" src=\"https://img-blog.csdnimg.cn/20210409162430222.png\"/>\n \n ## 去重distinct过滤字段要少 \n```sql\n#索引失效\nEXPLAIN\nSELECT DISTINCT * FROM student\n```\n \n```sql\n#索引生效\nEXPLAIN\nSELECT DISTINCT id,NAME FROM student\n```\n \n```sql\nEXPLAIN\nSELECT DISTINCT NAME FROM student\n```\n \n  \n - 带distinct的语句占用cpu时间高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较、过滤的过程会占用系统资源，如cpu时间\n \n ## where中使用默认值代替null \n  \n```sql\n#修改表，增加age字段，类型int，非空，默认值0\nALTER TABLE student ADD age INT NOT <span class=\"token boolean\">NULL DEFAULT <span class=\"token number\">0;\n```\n \n```sql\n#修改表，增加age字段的索引，名称为idx_age\nALTER TABLE student ADD INDEX idx_age (age);\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE age IS NOT <span class=\"token boolean\">NULL\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE age><span class=\"token number\">0\n```\n \n  \n - 并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关\n- 如果mysql优化器发现，走索引比不走索引成本还要高，就会放弃索引，这些条件 !=，&lt;>，is null，is not null经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃索引的\n- 如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思也相对清晰一点\n \n # 高级SQL优化 \n ## 批量插入性能提升 \n  \n  \n```sql\nINSERT INTO student (id,NAME) VALUES(<span class=\"token number\">4, \'name1\');\nINSERT INTO student (id,NAME) VALUES(<span class=\"token number\">5, \'name2\');\n```\n \n  \n```sql\nINSERT INTO student (id,NAME) VALUES(<span class=\"token number\">4, \'name1\'),(<span class=\"token number\">5, \'name2\');\n```\n \n  \n - 默认新增SQL有事务控制，导致每条都需要事务开启和事务提交；而批量处理是一次事务开启和提交。自然速度飞升\n- 数据量小体现不出来\n \n ## 批量删除优化 \n  \n  \n```sql\n#一次删除10万或者100万+？\ndelete from student where id &lt;<span class=\"token number\">100000;\n```\n \n```sql\n#采用单一循环操作，效率低，时间漫长\nfor（User user:list）{\n  delete from student;\n}\n```\n \n  \n```sql\n#分批进行删除，如每次500\nfor(){\ndelete student where id&lt;<span class=\"token number\">500;\n}\n```\n \n```sql\ndelete student where id>=<span class=\"token number\">500 and id&lt;<span class=\"token number\">1000;\n```\n \n  \n - 一次性删除太多数据，可能造成锁表，会有lock wait timeout exceed的错误，所以建议分批操作\n \n ## 伪删除设计 \n  \n  \n - 这里的删除只是一个标识，并没有从数据库表中真正删除，可以作为历史记录备查\n- 同时，一个大型系统中，表关系是非常复杂的，如电商系统中，商品作废了，但如果直接删除商品，其它商品详情，物流信息中可能都有其引用。\n- 通过where state=1或者where state=2过滤掉数据，这样伪删除的数据用户就看不到了，从而不影响用户的使用\n- 操作速度快，特别数据量很大情况下\n \n ## 提高group by语句的效率 \n  \n  \n```sql\nselect job，avg（salary） from employee  \ngroup by job \nhaving job = \'president\' or job =  \'managent\';\n```\n \n  \n```sql\nselect job，avg（salary） from employee \nwhere job = \'president\' or job =  \'managent\' \ngroup by job;\n```\n \n ## 复合索引最左特性 \n  \n```sql\nALTER TABLE student ADD INDEX idx_name_salary (NAME,salary)\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE NAME= \'name1\'\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE salary=<span class=\"token number\">3000\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE NAME= \'陈子枢\' AND salary=<span class=\"token number\">3000\n```\n \n  \n```sql\nEXPLAIN\nSELECT * FROM student WHERE salary=<span class=\"token number\">3000 AND NAME= \'name1\'\n```\n \n  \n - 复合索引也称为联合索引\n- 当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则\n- 联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的\n \n ## 排序字段创建索引 \n  \n```sql\n#使用*，包含了未索引的字段，导致索引失效\nEXPLAIN\nSELECT * FROM student ORDER BY NAME;\n\nEXPLAIN\nSELECT * FROM student ORDER BY NAME,salary\n\n#name字段有索引\nEXPLAIN\nSELECT id,NAME FROM student ORDER BY NAME\n\n#name和salary复合索引\nEXPLAIN\nSELECT id,NAME FROM student ORDER BY NAME,salary\n\nEXPLAIN\nSELECT id,NAME FROM student ORDER BY salary,NAME\n\n#排序字段未创建索引，性能就慢\nEXPLAIN\nSELECT id,NAME FROM student ORDER BY sex\n```\n \n ## 删除冗余和重复的索引 \n```sql\nSHOW INDEX FROM student \n\n#创建索引index_name\nALTER TABLE student ADD INDEX index_name (NAME)\n\n#删除student表的index_name索引\nDROP INDEX index_name ON student ;\n\n#修改表结果，删除student表的index_name索引\nALTER TABLE student DROP INDEX index_name ;\n\n#主键会自动创建索引，删除主键索引\nALTER TABLE student DROP PRIMARY KEY ;\n```\n \n  \n ## 不要有超过5个以上的表连接 \n - 关联的表个数越多，编译的时间和开销也就越大\n- 每次关联内存中都生成一个临时表\n- 应该把连接表拆开成较小的几个执行，可读性更高\n- 如果一定需要连接很多表才能得到数据，那么意味着这是个糟糕的设计了\n- 阿里规范中，建议多表联查三张表以下\n \n ## inner join 、left join、right join，优先使用inner join \n  \n - inner join 内连接，只保留两张表中完全匹配的结果集\n- left join会返回左表所有的行，即使在右表中没有匹配的记录\n- right join会返回右表所有的行，即使在左表中没有匹配的记录\n \n  \n - 如果inner join是等值连接，返回的行数比较少，所以性能相对会好一点\n- 同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。这是mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优\n \n ## in子查询的优化 \n  \n - 一种使用数据库SQL脚本实现\n- 一种使用程序实现<br/> 如需求：查询所有部门的所有员工：\n \n```sql\n#in子查询\nSELECT * FROM tb_user WHERE dept_id IN (SELECT id FROM tb_dept);\n#这样写等价于：\n\n#先查询部门表\nSELECT id FROM tb_dept\n\n#再由部门dept_id，查询tb_user的员工\nSELECT * FROM tb_user u,tb_dept d WHERE u.dept_id = d.id\n```\n \n  \n```sql\nList&lt;> resultSet;\nfor(int i=<span class=\"token number\">0;i&lt;B.length;i++) {\n  for(int j=<span class=\"token number\">0;j&lt;A.length;j++) {\n    if(A[i].id==B[j].id) {\n      resultSet.add(A[i]);\n      break;\n    }\n  }\n}\n```\n \n  \n  \n - 数据库最费劲的就是程序链接的释放。假设链接了两次，每次做上百万次的数据集查询，查完就结束，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，就会额外花费很多实际，这样系统就受不了了，慢，卡顿\n \n ## 尽量使用union all替代union \n  \n```sql\nSELECT * FROM student\nUNION\nSELECT * FROM student\n```\n \n  \n```sql\nSELECT * FROM student\nUNION ALL\nSELECT * FROM student\n```\n \n  \n - union和union all的区别是，union会自动去掉多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复\n- union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序\n- union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表UNION',NULL,0,0,0,NULL,'2021-01-04',354,'2021-01-04',30),
(67,41,'Docker基本用法','http://8.135.100.252/image/2019-10-1/8c5b826d-738f-43c9-9aa7-4439f357d909.jpg','Docker 提供了在称为容器的松散隔离环境中打包和运行应用程序的能力。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，包含运行应用程序所需的一切，因此您无需依赖主机上当前安装的内容。您可以在工作时轻松共享容器，并确保与您共享的每个人都获得以相同方式工作的相同容器。','','[[toc]]\n\n## 安装\n\n内核必须在3.10以上\n\n官网：https://docs.docker.com/\n\n- 卸载旧的版本\n``` bash\nyum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n- 配置需要的安装包\n\n``` bash\nyum install -y yum-utils\n```\n\n- 设置镜像的仓库\n\n``` bash\nyum-config-manager \\\n    --add-repo \\\n    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n- 启动Docker\n\n``` bash\nsystemctl start docker\n```\n\n- 验证Docker是否安装成功\n\n``` bash\ndocker run hello-world\n```\n\n- 查看hello world镜像\n\n\n- 卸载docker\n\n``` bash\nyum remove docker-ce docker-ce-cli containerd.io\n```\n\n``` bash\nrm -rf /var/lib/docker\n```\n\n``` bash\nrm -rf /var/lib/containerd\n```\n\n- 阿里云镜像加速\n\n\n``` bash\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n { \n\"registry-mirrors\": [\"https://6j1rwuhx.mirror.aliyuncs.com\"] \n}\n EOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n## 基本命令\n\n- 查看docker信息\n\n``` bash\ndocker version\ndocker info\n```\n\n- 查看所有的镜像id\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker images -aq\nd1165f221234\n```\n\n- 命令帮助文档\n\n> https://docs.docker.com/reference/\n\n- 镜像商店\n\n> https://hub.docker.com/\n\n- 搜索镜像商店500M以上的\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker search mysql --filter=STARS=500\n```\n\n- 下载镜像\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker pull mysql[:tag]  (tag:版本号)\n```\n\n- 删除镜像\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker images\nREPOSITORY    TAG       IMAGE ID       CREATED        SIZE\nhello-world   latest    d1165f221234   2 months ago   13.3kB\n[root@iZwz995sygwab04zwh0glhZ ~]# docker rmi -f d1165f221234\n[root@iZwz995sygwab04zwh0glhZ ~]# docker rmi -f 镜像id1 镜像id2 镜像id3\n[root@iZwz995sygwab04zwh0glhZ ~]# docker rmi -f $(docker images -aq)\n[root@iZwz995sygwab04zwh0glhZ ~]# docker rm -f $(docker ps -aq) 容器id\n[root@iZwz995sygwab04zwh0glhZ ~]# docker ps -a -q|xargs docker rm\n```\n\n- 使用交互方式运行并进入centos容器\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker run -it centos /bin/bash\n[root@iZwz995sygwab04zwh0glhZ ~]# exit\n```\n\n- 查看正在运行与曾经运行过的容器\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker ps\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n[root@iZwz995sygwab04zwh0glhZ ~]# docker ps -a\nCONTAINER ID   IMAGE         COMMAND    CREATED       STATUS                   PORTS     NAMES\ne4b8dd5b40e8   hello-world   \"/hello\"   2 hours ago   Exited (0) 2 hours ago             peaceful_joliot\n```\n\n- 容器不停止退出\n\n``` bash\nCtrl + P + Q\n```\n\n- 启动重启停止杀掉容器\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker start 容器id\n[root@iZwz995sygwab04zwh0glhZ ~]# docker restart 容器id\n[root@iZwz995sygwab04zwh0glhZ ~]# docker stop 容器id\n[root@iZwz995sygwab04zwh0glhZ ~]# docker kill 容器id\n```\n\n- 后台运行容器\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker run -d centos\n```\n\n容器在后台运行就必须有一个前台进程，当docker发现没有应用程序就会停止该进程\n\n如nginx启动后就会停止就是没有应用程序了\n\n- 查看日志\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker logs -f -t --tail 容器id\n```\n\n测试日志脚本\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker run -d centos /bin/sh -c \"while true:do echo Abraham;sleep 1;done\"\n[root@iZwz995sygwab04zwh0glhZ ~]# docker ps\n[root@iZwz995sygwab04zwh0glhZ ~]# docker logs -tf --tail 条数 容器id\n```\n\n- 查看进程信息\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker top 容器id\n```\n\n- 查看容器内部信息\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker inspect 容器id\n```\n\n- 进入容器后启动一个新的终端\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker exec -it 容器id /bin/bash\n```\n\n- 进入容器正在执行的终端\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker attach 容器id\n```\n\n- 拷贝容器内部文件到外部目录内\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# docker 容器id:/home/hello.java  /usr/home\n```\n\n## docker-compose\n\n``` shell\n[root@iZwz995sygwab04zwh0glhZ ~]# curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   379  100   379    0     0     47      0  0:00:08  0:00:07  0:00:01    81\n100   633  100   633    0     0     74      0  0:00:08  0:00:08 --:--:--  1255\n100 16.7M  100 16.7M    0     0   573k      0  0:00:29  0:00:29 --:--:--  833k\n\n[root@iZwz995sygwab04zwh0glhZ ~]# sudo chmod +x /usr/local/bin/docker-compose\n\n[root@iZwz995sygwab04zwh0glhZ bin]# docker-compose version\ndocker-compose version 1.25.5, build 8a1c60f6\ndocker-py version: 4.1.0\nCPython version: 3.7.5\nOpenSSL version: OpenSSL 1.1.0l  10 Sep 2019\n```\n\n[引导编写docker-compose.yml的官方文档](https://docs.docker.com/compose/compose-file/compose-file-v3/)',NULL,0,0,0,NULL,'2021-01-04',353,'2021-01-04',13),
(69,42,'十大排序算法','http://8.135.100.252/image/2019-10-1/7ef625b2-f39e-4bde-81fe-aaab434a309e.jpg','十种常见排序算法可以分为两大类：非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。  线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。','https://blog.csdn.net/qq_40161813/article/details/106367690','![Alt text](http://8.135.100.252/image/2019-10-1/7ef625b2-f39e-4bde-81fe-aaab434a309e.jpg)\n[[toc]]\n# 基本排序算法 \n  \n ## 0、算法概述 \n ### 0.1 算法分类 \n  \n 十种常见排序算法可以分为两大类：\n\n> 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。\n\n> 线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。\n \n  \n ### 0.2 算法复杂度 \n  \n - 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；\n- 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\n- 内排序：所有排序操作都在内存中完成；\n- 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\n- 时间复杂度： 一个算法执行所耗费的时间。\n- 空间复杂度：运行完一个程序所需内存的大小。\n \n  \n  \n - n: 数据规模\n- k: “桶”的个数\n- In-place: 占用常数内存，不占用额外内存\n- Out-place: 占用额外内存\n \n ### 0.3 算法的数据结构 \n ![Alt text](https://gitee.com/lovezzn/image-repository/raw/master/img/20200526230537.png) \n ### 0.4 算法分类 \n  \n ### 0.4 比较和非比较的区别 \n  \n  \n  \n ## <strong>1、冒泡排序（Bubble Sort）</strong> \n  \n ### <strong>1.1 算法描述</strong> \n - 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n- 针对所有的元素重复以上的步骤，除了最后一个；\n- 重复步骤1~3，直到排序完成。\n \n ### 1.2 动图演示 \n  \n ### 1.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\n/**\n * 冒泡排序\n *\n * @author zzn\n * @since 2019/10/18 19:53\n */\npublic class BubbleSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对原数组进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        for (int i = 1; i &lt; arr.length; i++) {\n            // 设定一个标记，若为 true，则表示此次循环没有进行交换，也就是待排序列已经有序了，那么排序就已经完成。\n            boolean flag = <span class=\"token boolean\">true;\n\n            for (int j = 0; j &lt; arr.length - i; j++) {\n                if (arr[j] > arr[j + 1]) {\n                    int tmp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = tmp;\n\n                    flag = <span class=\"token boolean\">false;\n                }\n            }\n\n            if (flag) {\n                break;\n            }\n        }\n\n        return arr;\n    }\n\n\n    @Test\n    public void testList() {\n        // ArrayList&lt;Integer> list = new ArrayList&lt;>(Arrays.asList(11, 334, 64, 32, 667, 346, 478, 3, 1, 789, 453, 4));\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n    }\n\n}\n\n```\n \n ### 1.4 算法分析 \n )\n- 空间复杂度：O(1)\n- 稳定性：稳定\n \n ## 2、选择排序（Selection Sort） \n  \n ### 2.1 算法步骤 \n  \n \n ### 2.2 动图演示 \n  \n ### 2.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 选择排序\n *\n * @author zzn\n * @since 2019/10/18 21:03\n */\npublic class SelectionSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对原数组进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        // 总共要经过 N-1 轮比较\n        for (int i = 0; i &lt; arr.length; i++) {\n            // 记录最小值的元素下标,默认是 第一个\n            int min = i;\n\n            // 每轮需要比较的次数 N-i\n            for (int j = i + 1; j &lt; arr.length; j++) {\n                if (arr[j] &lt; arr[min]) {\n                    // 记录目前内找到的最小值的元素下标\n                    min = j;\n                }\n            }\n\n            // 将找到的最小值和 i  位置所在的值进行交换\n            if (i != min) {\n                int tmp = arr[i];\n                arr[i] = arr[min];\n                arr[min] = tmp;\n            }\n\n        }\n\n        return arr;\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n    }\n}\n```\n \n ### 2.4 算法分析 \n )\n- 空间复杂度：O(1)\n- 稳定性：不稳定\n \n ## 3、插入排序 \n  \n  \n ### 3.1 算法步骤 \n - 将排序序列的第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n \n ### 3.2 动图演示 \n  \n ### 3.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 插入排序\n *\n * @author zzn\n * @since 2019/10/18 22:50\n */\npublic class InsertSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对原数组进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        // 从下标为 1 的元素开始选择合适的位置插入，因为下标为 0 的只有一个元素，默认是有序的\n        for (int i = 0; i &lt; arr.length; i++) {\n            // 记录要插入的数据\n            int tmp = arr[i];\n\n            // 从已经排序的序列最右边开始比较，找到比其小的数\n            int j = i;\n            while (j > 0 &amp;&amp; tmp &lt; arr[j - 1]) {\n                arr[j] = arr[j - 1];\n                j--;\n            }\n\n            // 存在比其小的数，插入\n            if (j != i) {\n                arr[j] = tmp;\n            }\n        }\n\n        return arr;\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n}\n```\n \n ### 3.4 算法分析 \n )\n- 空间复杂度：O(1)\n- 稳定性：稳定\n \n ## 4、希尔排序 \n  \n  \n - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n \n  \n ### 4.1 算法步骤 \n - 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n- 按增量序列个数 k，对序列进行 k 趟排序；\n- 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n \n ### 4.2 动图演示 \n  \n ### 4.3 画图解析 \n ![Alt text](https://gitee.com/lovezzn/image-repository/raw/master/img/20200526230715.jpg) \n ### 4.4 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 希尔排序\n *\n * @author zzn\n * @since 2019/10/19 0:16\n */\npublic class ShellSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对原数组进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        // 设置增量\n        int gap = arr.length / 2;\n\n        while (gap > 0) {\n            for (int i = gap; i &lt; arr.length; i++) {\n                int tmp = arr[i];\n                int j = i - gap;\n                while (j >= 0 &amp;&amp; arr[j] > tmp) {\n                    arr[j + gap] = arr[j];\n                    j -= gap;\n                }\n                arr[j + gap] = tmp;\n            }\n            gap = gap / 2;\n        }\n\n        return arr;\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{9,8,6,4,3,5,0};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n}\n\n```\n \n ### 4.5 算法分析 \n  n)\n- 空间复杂度：O(1)\n- 稳定性：不稳定\n \n ## 5、归并排序 \n  \n  \n - 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；\n- 自下而上的迭代；\n \n  \n \n\n\n \n  \n ### 5.1 算法步骤 \n - 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n- 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n- 重复步骤 3 直到某一指针达到序列尾；\n- 将另一序列剩下的所有元素直接复制到合并序列尾。\n \n ### 5.2 动图演示 \n  \n ### 5.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 归并排序\n *\n * @author zzn\n * @since 2019/10/19 6:11\n */\npublic class MergeSort implements IArraySort {\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对原数组进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        if (arr.length &lt; 2) {\n            return arr;\n        }\n\n        // 把长度为n的输入序列分成两个长度为n/2的子序列\n        int middle = arr.length / 2;\n\n        int[] left = Arrays.copyOfRange(arr, 0, middle);\n        int[] right = Arrays.copyOfRange(arr, middle, arr.length);\n\n        return merge(sort(left), sort(right));\n    }\n\n    private int[] merge(int[] left, int[] right) {\n\n        int[] result = new int[left.length + right.length];\n        int i = 0;\n        while (left.length > 0 &amp;&amp; right.length > 0) {\n            if (left[0] &lt;= right[0]) {\n                result[i++] = left[0];\n                left = Arrays.copyOfRange(left, 1, left.length);\n            } else {\n                result[i++] = right[0];\n                right = Arrays.copyOfRange(right, 1, right.length);\n            }\n        }\n\n        while (left.length > 0) {\n            result[i++] = left[0];\n            left = Arrays.copyOfRange(left, 1, left.length);\n        }\n\n        while (right.length > 0) {\n            result[i++] = right[0];\n            right = Arrays.copyOfRange(right, 1, right.length);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n}\n```\n \n ### 5.4 算法分析 \n - 平均时间复杂度：O(n log n)\n- 最好情况：O(n log n)\n- 最坏情况：O(n log n)\n- 空间复杂度：O(n)\n- 稳定性：稳定\n \n ## 6、 快速排序 \n  \n  \n  \n  \n \n\n \n ### 6.1 算法步骤 \n - 从数列中挑出一个元素，称为 “基准”（pivot）;\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\n \n ### 6.2 动图演示 \n  \n ### 6.3 算法代码 \n - 版本一\n \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 快速排序\n *\n * @author zzn\n * @since 2019/10/19 10:31\n */\npublic class QuickSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        return quickSort(arr, 0, arr.length - 1);\n    }\n\n    private int[] quickSort(int[] arr, int left, int right) {\n        if (left &lt; right) {\n            int partitionIndex = partition(arr, left, right);\n            quickSort(arr, left, partitionIndex - 1);\n            quickSort(arr, partitionIndex + 1, right);\n        }\n        return arr;\n    }\n\n    private int partition(int[] arr, int left, int right) {\n        // 设定基准值（pivot）\n        int pivot = left;\n        int index = pivot + 1;\n        for (int i = index; i &lt;= right; i++) {\n            if (arr[i] &lt; arr[pivot]) {\n                swap(arr, i, index);\n                index++;\n            }\n        }\n        swap(arr, pivot, index - 1);\n        return index - 1;\n    }\n\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n}\n\n```\n \n - 版本二\n \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 快速排序 2\n * 从左边找比基数大的值，从右边找比基数小的值，然后进行交换\n *\n * @author zzn\n * @since 2019/10/19 12:25\n */\npublic class QuickSort02 implements IArraySort {\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n        quickSort(arr, 0, arr.length - 1);\n        return arr;\n    }\n\n    private void quickSort(int[] arr, int low, int high) {\n        int left, right, temp, t;\n        if (low > high)\n            return;\n        left = low;\n        right = high;\n        //temp就是基准位\n        temp = arr[low];\n\n        while (left &lt; right) {\n            //先看右边，依次往左递减\n            while (temp &lt;= arr[right] &amp;&amp; left &lt; right) {\n                right--;\n            }\n            //再看左边，依次往右递增\n            while (temp >= arr[left] &amp;&amp; left &lt; right) {\n                left++;\n            }\n            //如果满足条件则交换\n            if (left &lt; right) {\n                t = arr[right];\n                arr[right] = arr[left];\n                arr[left] = t;\n            }\n\n        }\n        //最后将基准为与i和j相等位置的数字交换\n        arr[low] = arr[left];\n        arr[left] = temp;\n        //递归调用左半数组\n        quickSort(arr, low, right - 1);\n        //递归调用右半数组\n        quickSort(arr, right + 1, high);\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 11, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n\n}\n\n```\n \n ### 6.4 算法分析 \n )\n- 空间复杂度：O(log n)\n- 稳定性：不稳定\n \n ## 7、堆排序 \n  \n - 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；\n- 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；\n \n  \n ### 7.1 算法步骤 \n - 创建一个堆 H[0……n-1]；\n- 把堆首（最大值）和堆尾互换；\n- 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；\n- 重复步骤 2，直到堆的尺寸为 1。\n \n ### 7.2 动图演示 \n  \n ### 7.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 堆排序\n *\n * @author zzn\n * @since 2019/10/19 15:37\n */\npublic class HeapSort implements IArraySort {\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        int len = arr.length;\n        // 构建一个最大堆\n        buildMaxHeap(arr, len);\n\n        // 将最后一个元素和第一个元素的位置进行交换\n        for (int i = len - 1; i > 0; i--) {\n            swap(arr, 0, i);\n            len--;\n            heapify(arr, 0, len);\n        }\n\n        return arr;\n    }\n\n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    /**\n     * 构建一个最大堆\n     *\n     * @param arr 数组\n     * @param len 长度\n     */\n    private void buildMaxHeap(int[] arr, int len) {\n        for (int i = len / 2; i >= 0; i--) {\n            heapify(arr, i, len);\n        }\n    }\n\n    private void heapify(int[] arr, int i, int len) {\n        // 左子树\n        int left = 2 * i + 1;\n        // 右子树\n        int right = 2 * i + 2;\n        // 父节点\n        int largest = i;\n\n        // 如果有左子树，且左子树的值大于父节点，则将最大指针指向左子树\n        if (left &lt; len &amp;&amp; arr[left] > arr[largest]) {\n            largest = left;\n        }\n\n        // 如果有右子树，且右子树的值大于父节点，则将最大指针指向右子树\n        if (right &lt; len &amp;&amp; arr[right] > arr[largest]) {\n            largest = right;\n        }\n\n        // 如果父节点不是最大值，则将父节点与最大值交换，并且递归调整父节点交换的位置\n        if (largest != i) {\n            swap(arr, i, largest);\n            heapify(arr, largest, len);\n        }\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 11, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n\n}\n```\n \n ### 7.4 算法分析 \n - 平均时间复杂度：O(n log n)\n- 最好情况：O(n log n)\n- 最坏情况：O(n log n)\n- 空间复杂度：O(1)\n- 稳定性：不稳定\n \n ## 8、计数排序 \n  \n  \n  \n  \n  \n ### 8.1 算法步骤 \n - （1）找出待排序的数组中最大和最小的元素\n- （2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项\n- （3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）\n- （4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1\n \n ### 8.2 动图演示 \n  \n ### 8.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 计数排序\n *\n * @author zzn\n * @since 2019/10/19 16:02\n */\npublic class CountingSort implements IArraySort {\n\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        int maxValue = getMaxValue(arr);\n\n        return countingSort(arr, maxValue);\n    }\n\n    private int[] countingSort(int[] arr, int maxValue) {\n        int bucketLen = maxValue + 1;\n        int[] bucket = new int[bucketLen];\n\n        for (int value : arr) {\n            bucket[value]++;\n        }\n\n        int sortedIndex = 0;\n        for (int j = 0; j &lt; bucketLen; j++) {\n            while (bucket[j] > 0) {\n                arr[sortedIndex++] = j;\n                bucket[j]--;\n            }\n        }\n        return arr;\n    }\n\n    private int getMaxValue(int[] arr) {\n        int maxValue = arr[0];\n        for (int value : arr) {\n            if (maxValue &lt; value) {\n                maxValue = value;\n            }\n        }\n        return maxValue;\n    }\n\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{1,2,3,4,5,6,7,8,9,1,2,4,5,1,4,6,8,7,2,4,6,4,5,4,2,1,6,4,8,7};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n}\n\n```\n \n ### 8.4 算法分析 \n - 平均时间复杂度：O(n + k)\n- 最好情况：O(n + k)\n- 最坏情况：O(n + k)\n- 空间复杂度：O(k)\n- 稳定性：稳定\n \n ## 9、桶排序 \n  \n - 在额外空间充足的情况下，尽量增大桶的数量\n- 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中\n \n  \n ### 9.1 算法描述 \n - 设置一个定量的数组当作空桶；\n- 遍历输入数据，并且把数据一个一个放到对应的桶里去；\n- 对每个不是空的桶进行排序；\n- 从不是空的桶里把排好序的数据拼接起来\n \n ### 9.2 图片演示 \n  \n  \n  \n  \n ### 9.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 桶排序\n *\n * @author zzn\n * @since 2019/10/19 17:03\n */\npublic class BucketSort implements IArraySort {\n\n    private static final InsertSort insertSort = new InsertSort();\n\n    @Override\n    public int[] sort(int[] sourceArray) {\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        return bucketSort(arr, 5);\n    }\n\n    private int[] bucketSort(int[] arr, int bucketSize) {\n        if (arr.length == 0) {\n            return arr;\n        }\n\n        int minValue = arr[0];\n        int maxValue = arr[0];\n        for (int value : arr) {\n            if (value &lt; minValue) {\n                minValue = value;\n            } else if (value > maxValue) {\n                maxValue = value;\n            }\n        }\n\n        int bucketCount = (maxValue - minValue) / bucketSize + 1;\n        int[][] buckets = new int[bucketCount][0];\n\n        // 利用映射函数将数据分配到各个桶中\n        for (int i = 0; i &lt; arr.length; i++) {\n            int index = (arr[i] - minValue) / bucketSize;\n            buckets[index] = arrAppend(buckets[index], arr[i]);\n        }\n\n        int arrIndex = 0;\n        for (int[] bucket : buckets) {\n            if (bucket.length &lt;= 0) {\n                continue;\n            }\n            // 对每个桶进行排序，这里使用了插入排序\n            bucket = insertSort.sort(bucket);\n            for (int value : bucket) {\n                arr[arrIndex++] = value;\n            }\n        }\n\n        return arr;\n    }\n\n    /**\n     * 自动扩容，并保存数据\n     *\n     * @param arr\n     * @param value\n     */\n    private int[] arrAppend(int[] arr, int value) {\n        arr = Arrays.copyOf(arr, arr.length + 1);\n        arr[arr.length - 1] = value;\n        return arr;\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 11, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n}\n\n```\n \n ### 9.4 算法分析 \n )\n- 空间复杂度：O(n+k)\n- 稳定性：稳定\n \n ## 10、基数排序 \n  \n ### 10.1 基数排序 vs 计数排序 vs 桶排序 \n  \n  \n - 基数排序：根据键值的每位数字来分配桶；\n- 计数排序：每个桶只存储单一键值；\n- 桶排序：每个桶存储一定范围的数值；\n \n ### 10.2 LSD 基数排序动图演示 \n  \n ### 10.3 算法代码 \n```java\npackage com.zzn.sort.impl;\n\nimport com.zzn.sort.IArraySort;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\n/**\n * 基数排序\n * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9\n *\n * @author zzn\n * @since 2019/10/19 18:56\n */\npublic class RadixSort implements IArraySort {\n\n\n    @Override\n    public int[] sort(int[] sourceArray){\n        // 对 arr 进行拷贝，不改变参数内容\n        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\n\n        int maxDigit = getMaxDigit(arr);\n        return radixSort(arr, maxDigit);\n    }\n\n    /**\n     * 获取最高位数\n     */\n    private int getMaxDigit(int[] arr) {\n        int maxValue = getMaxValue(arr);\n        return getNumLenght(maxValue);\n    }\n\n    private int getMaxValue(int[] arr) {\n        int maxValue = arr[0];\n        for (int value : arr) {\n            if (maxValue &lt; value) {\n                maxValue = value;\n            }\n        }\n        return maxValue;\n    }\n\n    protected int getNumLenght(long num) {\n        if (num == 0) {\n            return 1;\n        }\n        int lenght = 0;\n        for (long temp = num; temp != 0; temp /= 10) {\n            lenght++;\n        }\n        return lenght;\n    }\n\n    private int[] radixSort(int[] arr, int maxDigit) {\n        int mod = 10;\n        int dev = 1;\n\n        for (int i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {\n            // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)\n            int[][] counter = new int[mod * 2][0];\n\n            for (int j = 0; j &lt; arr.length; j++) {\n                int bucket = ((arr[j] % mod) / dev) + mod;\n                counter[bucket] = arrayAppend(counter[bucket], arr[j]);\n            }\n\n            int pos = 0;\n            for (int[] bucket : counter) {\n                for (int value : bucket) {\n                    arr[pos++] = value;\n                }\n            }\n        }\n\n        return arr;\n    }\n\n    /**\n     * 自动扩容，并保存数据\n     *\n     * @param arr\n     * @param value\n     */\n    private int[] arrayAppend(int[] arr, int value) {\n        arr = Arrays.copyOf(arr, arr.length + 1);\n        arr[arr.length - 1] = value;\n        return arr;\n    }\n\n    @Test\n    public void testList() {\n        int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 11, 3, 1, 789, 453, 4};\n        int[] sort = sort(ints);\n        System.out.println( \"sort = \" + Arrays.toString(sort));\n\n    }\n}\n\n```\n \n ### 10.4 算法分析 \n - 平均时间复杂度：O(n * k)\n- 最好情况：O(n * k)\n- 最坏情况：O(n * k)\n- 空间复杂度：O(n+k)\n- 稳定性：稳定\n \n  \n ``` mysql\n        for (int j = 0; j &lt; arr.length; j++) {\n            int bucket = ((arr[j] % mod) / dev) + mod;\n            counter[bucket] = arrayAppend(counter[bucket], arr[j]);\n        }\n\n        int pos = 0;\n        for (int[] bucket : counter) {\n            for (int value : bucket) {\n                arr[pos++] = value;\n            }\n        }\n    }\n\n    return arr;\n}\n\n/**\n * 自动扩容，并保存数据\n *\n * @param arr\n * @param value\n */\nprivate int[] arrayAppend(int[] arr, int value) {\n    arr = Arrays.copyOf(arr, arr.length + 1);\n    arr[arr.length - 1] = value;\n    return arr;\n}\n\n@Test\npublic void testList() {\n    int[] ints = new int[]{11, 334, 64, 32, 667, 346, 478, 11, 3, 1, 789, 453, 4};\n    int[] sort = sort(ints);\n    System.out.println(\"sort = \" + Arrays.toString(sort));\n\n}\n```\n \n  \n ``` mysql\n\n### 10.4 算法分析\n\n- 平均时间复杂度：O(n * k)\n- 最好情况：O(n * k)\n- 最坏情况：O(n * k)\n- 空间复杂度：O(n+k)\n- 稳定性：稳定\n```',NULL,0,0,0,NULL,'2021-01-05',353,'2021-01-05',15),
(80,24,'RabbitMQ通信原理','http://8.135.100.252/image/2019-10-1/c47e0a7b-c382-49b3-a1bb-3826350d5bb6.jpg','RabbitMQ通信原理','','# RabbitMQ通信原理',NULL,0,0,0,NULL,'2021-08-15',354,'2021-08-15',0),
(81,22,'浅谈黑客如何进行短信轰炸','http://8.135.100.252/image/2019-10-1/98044f81-5b0a-4e9d-8548-f99667372286.jpg','在生活中我们都听说过短信、电话轰炸这一类新闻，这种恶作剧不得不让我们产生注销手机号码的想法，那么为我们怎么理解这种轰炸原理？又怎么去进行防范呢？','','# 浅谈短信轰炸\n\n![Alt text](http://8.135.100.252/image/2019-10-1/98044f81-5b0a-4e9d-8548-f99667372286.jpg)\n\n在生活中我们都听说过短信、电话轰炸这一类新闻，这种恶作剧不得不让我们产生注销手机号码的想法，那么为我们怎么理解这种轰炸原理？又怎么去进行防范呢？\n\n\n## 轰炸原理\n黑客要想轰炸，需要有多个发送源，那么源头来自哪里呢？以前常有新闻传道某某靠“猫池”盈利被捉，没错，类似这种非法代理，但是，这是极不安全的，如果代理被捉，那么黑客的信息就会被警方截获，那么问题来了，哪里有相对安全的手段进行持续的轰炸呢？答案是某些站点的短信发送api接口，黑客对这些泄露的接口进行大量的收集，通过分布式多线程定时的脚本对我们的手机号发送，完美的实现了“借刀杀人”的渗透策略。\n\n\n## 信息的泄露\n\n这也就是所谓的信息收集的过程，要想对我们进行渗透，黑客得知道到我们的存在，那么这些信息从何获取呢？一般来说就是社工库，这种库保留了很多关于我们在网络上流动的信息，无论是网络交易、平台注册、数据存储等等都可能会引发信息的泄露，只要有一点点关键信息被黑客取得了，如姓名、QQ、支付宝、微信、手机号等等，就可以展开我们在网络上活动的很多关联信息，所以我们要保证信息安全就得从日常生活做起，比如关闭陌生人浏览信息权限、关键账号用零网络活动的手机号绑定、慎重在中小甚至不安全网站注册、假名网购、隐藏账号、各平台密码保持不同等等操作。\n\n\n## 渗透的代价\n\n黑客不会无冤无仇无利益对我们进行渗透，每一次渗透都要花费一定时间成本、精力以及承担一定的风险，这个行为有他必然的目的，我们可能是间接目标，也可能是直接目标，所以我们可以反向思考一下，最近有无惹什么人、触及什么人利益，或者是我的同事或朋友有无相同的遭遇，如果有，不妨大胆推测那个人与黑客本人有脱不开的关系。\n\n## 防止轰炸\n对于普通人，如果轰炸源是某外国网站代理，不妨查找一下该网站，说不定会有制止的方式，如果是国内互联网企业，那就是“借刀杀人”了，这种在白名单的企业360也拦截不了，即刻打电话找网警举报，预计24小时内就能得到平息。',NULL,0,0,0,NULL,'2021-08-15',357,'2021-08-15',10),
(82,24,'Https原理详解','http://8.135.100.252/image/2019-10-1/7221ab9f-2aa4-4b91-ac4f-cc840e973fce.jpg','https','','# https',NULL,0,0,0,NULL,'2021-08-15',356,'2021-08-15',1),
(83,44,'pytorch深度学习','http://8.135.100.252/image/2019-10-1/98ce81a3-0bf8-472a-aeda-5246cd32533f.jpg','深度学习','','# 深度学习',NULL,0,0,0,NULL,'2021-08-15',353,'2021-08-15',0),
(84,45,'CSDN文章转Markdown输出','https://img1.baidu.com/it/u=3537785567,854591175&fm=26&fmt=auto&gp=0.jpg','该脚本先伪造合法的请求头，再使用BeautifulSoup抓取页面html代码，通过正则表达式进行数据的清洗，最后写入md文件输出。','','# Python爬虫脚本\n\n注意：正则表达式并不全面，有的标签可能清洗不掉，实际情况请按个人需求做进一步的修改。\n\n``` py\nimport requests\nfrom os import path\nimport re\nfrom requests_html import HTML\nimport json\nfrom bs4 import BeautifulSoup\n\nclass csdn:\n    def __init__(self, user, head):\n        \"\"\"\n        初始化请求参数\n        :param user: CSDN用户ID\n        :param head: 访问请求头\n        \"\"\"\n        self.useinfo = user\n        self.url = f\"https://blog.csdn.net/{user}?type=blog\"\n        self.head = head\n    def write_md(self,file,txt):\n        \"\"\"\n        写入文本内容到文件\n        :param file: 文件名\n        :param txt: 文本内容\n        :return: 写入结果\n        \"\"\"\n        try:\n            with open(file, \'w\', encoding=\'utf-8\') as f:\n                f.write(txt)\n            return f\"{file}写入: 成功\"\n        except:\n            return f\"{file}写入: 失败\"\n    def get_status(self):\n        \"\"\"\n        对URL进行访问测试\n        :return: 访问结果\n        \"\"\"\n        get = requests.get(url=self.url, headers=self.head)\n        self.get = get\n        if get.status_code == 200:\n            print(f\'访问请求成功\')\n            return True\n        else:\n            print(f\"访问请求失败\")\n            return False\n    def get_list(self):\n        \"\"\"\n        获取该用户所有文章列表\n        :return: 返回列表信息\n        \"\"\"\n        # get = requests.get(url=self.url, headers=self.head)\n        self.get.encoding = \'utf-8\'\n        text = self.get.text\n        list = BeautifulSoup(text, \'html.parser\')\n        # print(list)\n        title_list = list.find_all(\'h4\')\n        url = list.find_all(\'a\')\n        txt_id = str(title_list[0]).split(\'=\')[0].split(\' \')[1]\n        # print(txt_id)\n        rule = re.compile(r\'\'+self.useinfo)\n        i = str(url[9])\n\n        print(i)\n        # print(i.split(self.url)[0])\n\n        # print(re.findall(rule, i))\n        # Get_url = str(i)\n        # print(Get_url)\n\n        # print(title_list)\n        print(txt_id)\n\n        # print(txt_id)\n        # print(re.match(txt_id, text).group())\n\n        # print(title_list[1])\n\n        sum = len(title_list)  # 统计当前文章数量\n        print(f\"当前主页共有: {sum} 篇文章\")\n\n\n        print(\"获取到的文章列表如下:\")\n        for tile in title_list:\n            tit = str(tile).split(\'\">\')[1].split(\'<\')[0]\n            print(tit)\n\n    # def get_list_url(self):\n\n    def doc(self, title=\'\', url=\'\'):\n        \"\"\"\n        爬取单篇文章内容\n        :param title: 文章标题\n        :param url:\n        :return: str(文章内容)\n        \"\"\"\n        file = f\"{title}.md\"\n        get = requests.get(url=url, headers=self.head)\n\n        if get.status_code == 200:\n            print(f\"结果: [ {title} ]请求成功\")\n        else:\n            print(f\"结果: [ {title} ]请求失败\")\n            return False\n        get.encoding = get.apparent_encoding\n        soup = BeautifulSoup(get.text, \'lxml\')\n        text_list = soup.find(\'div\', \"markdown_views\")\n        # print(text_list)\n        info = \"\"\n        for i in text_list:\n            info = f\"{str(info)} {i}\"\n            info = re.sub(r\'.*svg.*\', \'\', info)\n\n            info = re.sub(r\'.*svg.*\', \'\', info)\n            info = re.sub(r\'<path.*\', \'\', info)\n\n            # 转换菜单\n            info = re.sub(r\'<h1><a id=\".*\"></a>\', \'# \', info)\n            info = re.sub(r\'<h2><a id=\".*\"></a>\', \'## \', info)\n            info = re.sub(r\'<h3><a id=\".*\"></a>\', \'### \', info)\n            info = re.sub(r\'</h.*>\', \'\', info)\n\n            # 转换正文\n            info = re.sub(r\'<.*p>\', \'\', info)\n\n\n            # 转换代码块(bash)\n            # 判断代码类型\n            # print(i)\n\n            get = re.search(r\'(.*)<pre><code class=\"prism language(.*)\"><\', string=str(i))\n            # 判断是否存在代码块\n            if get:\n                # 判断编程类型\n                # print(f\"存在代码: {i}\")\n                code_type = get.group().split(\'-\')[1].replace(\'\">\', \'\').replace(\'<\', \'\')\n                # print(f\"代码类型: {code_type}\")\n                # d = input(\'dd\')\n                # print(f\"替换: rf\'<pre><code class=\\\"prism language-{code_type}\\\">\'\")\n                info = re.sub(rf\'(.*)<pre><code(.*)language-{code_type}\">\', f\'```{code_type}\\n\', info)\n\n                # info = re.sub(r\' <pre><code class=\"prism language-bash\">\', \'```bash\\n\', info)\n\n                info = re.sub(r\' ```\', \'```\', info)\n                info = re.sub(r\'</code></pre>\', \'```\\n\', info)\n\n                # info = re.sub(r\'</span>\', \'\', info)\n\n        info = re.sub(r\'<pre><code class=\"prism language-bash\"><span class=\"token function\">\', \'\', info)\n        info = re.sub(r\'</span>\', \'\', info)\n\n        info = re.sub(r\'</code></pre>\', f\'```\\n\', info)\n        info = re.sub(r\'<pre><code>\', \'``` shell\\n\', info)\n        # info = re.sub(r\'<pre><code class=\"prism language-bash\"><span class=\"token function\">\', \'```bash\\n\', info)\n        info = re.sub(r\"\"\"<span class=\"token string\">\"\"\", \' \', info)\n        info = re.sub(r\"\"\"<span class=\"token function\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<span class=\"token keyword\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<span class=\"token operator\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<span class=\"token comment\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<pre><code class=\"prism language-bash\">\"\"\", \'```bash\\n\', info)\n        info = re.sub(r\'&gt;\', \'>\', info)\n        info = re.sub(r\"\"\"<span class=\"token punctuation\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<li>\"\"\", \'- \', info)\n        info = re.sub(r\"\"\"<ul>\"\"\", \'\', info)\n        info = re.sub(r\"\"\"</ul>\"\"\", \'\', info)\n        info = re.sub(r\"\"\"</li>\"\"\", \'\\n\', info)\n        info = re.sub(r\"\"\"<img src=\\\"\"\"\", \'![Alt text](\', info)\n        info = re.sub(r\"\"\"\\\"/>\"\"\", \')\', info)\n        info = re.sub(r\"\"\"<ol>\"\"\", \'\', info)\n        info = re.sub(r\"\"\"</ol>\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<blockquote>\"\"\", \'\', info)\n        info = re.sub(r\"\"\"</blockquote>\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<span class=\"token number\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<span class=\"token class-name\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<span class=\"token annotation punctuation\">\"\"\", \'\', info)\n        info = re.sub(r\"\"\"<!-- -->\"\"\", \'\', info)\n        status = up.write_md(file=file, txt=info)\n        print(status)\n\n\n#  变量赋值\nHeaders = {\"accept\" : \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\",\n           \"accept-encoding\" : \"gzip, deflate, br\",\n           \"accept-language\": \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\",\n           \"cache-control\": \"max-age=0\",\n           \'user-agent\': \'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36 Edg/90.0.818.39}\'\n           }\n\n# 目标用户\nuser = \'qq_36427244\'\n# head = \'user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36 Edg/90.0.818.39\'\n\n\n#  开始实例化\nup = csdn(user=user, head=Headers)\n\n# 指定markdown输出名及文章地址\nup.doc(title=\'select\', url=\'https://blog.csdn.net/qq_36427244/article/details/101199726\')\n# get = up.get_status()  # 获取请求状态\n# if get:\n#     print(\'开始获取文章列表\')\n#     up.get_list()\n# else:\n#     exit(\'请检查用户ID是否有误或者网络是否通畅\')\n\n```',NULL,0,0,0,NULL,'2021-08-18',356,'2021-08-18',2);

/*Table structure for table `tb_article_attachment` */

DROP TABLE IF EXISTS `tb_article_attachment`;

CREATE TABLE `tb_article_attachment` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `article_id` int(11) DEFAULT NULL COMMENT '文章ID',
  `url` varchar(100) DEFAULT NULL COMMENT '路径',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='文章附件';

/*Data for the table `tb_article_attachment` */

insert  into `tb_article_attachment`(`id`,`article_id`,`url`) values 
(1,5,'http://localhost:8081/cms/upload/fc9891d1-5496-41c5-a218-c7fa70826950.jpg'),
(2,5,'http://localhost:8081/cms/upload/65d115df-309c-41ea-a84c-7b3cf5e80095.jpg'),
(3,6,'http://localhost:8081/cms/upload/6c337640-cc50-4d6a-bfb2-46452cbeda9f.jpg');

/*Table structure for table `tb_article_tag` */

DROP TABLE IF EXISTS `tb_article_tag`;

CREATE TABLE `tb_article_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) DEFAULT NULL,
  `tag_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=171 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='文章标签';

/*Data for the table `tb_article_tag` */

insert  into `tb_article_tag`(`id`,`article_id`,`tag_id`) values 
(48,44,4),
(120,83,8),
(121,83,17),
(122,83,25),
(123,82,19),
(124,81,10),
(125,80,19),
(129,60,19),
(130,60,5),
(138,63,5),
(139,63,11),
(141,64,13),
(155,61,17),
(156,61,16),
(157,69,17),
(158,69,16),
(160,62,15),
(161,66,15),
(164,67,9),
(165,67,13),
(166,65,9),
(169,84,21),
(170,84,25);

/*Table structure for table `tb_channel` */

DROP TABLE IF EXISTS `tb_channel`;

CREATE TABLE `tb_channel` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(100) DEFAULT NULL COMMENT '名称',
  `parent_id` int(11) DEFAULT NULL COMMENT '上级栏目',
  `channel_img` varchar(255) DEFAULT NULL COMMENT '栏目图片',
  `summary` varchar(200) DEFAULT NULL COMMENT '摘要',
  `single` char(1) DEFAULT NULL COMMENT '是否单页 .Y为单页，Null为不单页',
  `url` varchar(100) DEFAULT NULL COMMENT '外链URL',
  `seo_title` varchar(100) DEFAULT NULL COMMENT 'SEO标题',
  `seo_keyword` varchar(200) DEFAULT NULL COMMENT 'SEO关键字',
  `seo_description` varchar(200) DEFAULT NULL COMMENT 'SEO描述',
  `content` text DEFAULT NULL COMMENT '正文',
  `create_user` int(11) DEFAULT NULL COMMENT '创建人',
  `create_date` date DEFAULT NULL COMMENT '创建时间',
  `pos` char(1) DEFAULT NULL COMMENT '位置',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=49 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='栏目';

/*Data for the table `tb_channel` */

insert  into `tb_channel`(`id`,`name`,`parent_id`,`channel_img`,`summary`,`single`,`url`,`seo_title`,`seo_keyword`,`seo_description`,`content`,`create_user`,`create_date`,`pos`) values 
(19,'Go',0,'https://img1.baidu.com/it/u=3163295019,441786778&fm=15&fmt=auto&gp=0.jpg','Go是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Go的语法接近C语言，但对于变量的声明有所不同。与C++相比，Go并不包括如枚举、异常处理、继承、泛型、断言、虚函数等功能，但增加了切片型、并发、管道、垃圾回收、接口等特性的语言级支持。','N','','','','','',320,'2020-12-22','B'),
(20,'Java',0,'https://img0.baidu.com/it/u=593216026,135847718&fm=26&fmt=auto&gp=0.jpg','Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。','N','','','','','',320,'2020-12-22','A'),
(22,'网络安全',41,'https://img2.baidu.com/it/u=2465035512,3291108693&fm=26&fmt=auto&gp=0.jpg','网络安全（Cyber Security）是指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。','N','','','','',' ',320,'2020-12-22','A'),
(23,'大数据',20,'https://img0.baidu.com/it/u=3695179112,1260342134&fm=26&fmt=auto&gp=0.jpg','大数据是指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。','N','','','','','',320,'2020-12-22','B'),
(24,'网络协议',41,'http://image.16pic.com/00/19/43/16pic_1943350_s.jpg?imageView2/0/format/png','网络协议是网络上所有设备（网络服务器、计算机及交换机、路由器、防火墙等）之间通信规则的集合，它规定了通信时信息必须采用的格式和这些格式的意义。大多数网络都采用分层的体系结构，每一层都建立在它的下层之上，向它的上一层提供一定的服务，而把如何实现这一服务的细节对上一层加以屏蔽。','N','','','','','',320,'2020-12-22','A'),
(25,'Spring',20,'https://img1.baidu.com/it/u=4162759595,858645477&fm=26&fmt=auto&gp=0.jpg','Spring是Java EE编程领域的一个轻量级开源框架。Spring是一个开源容器框架，它集成各类型的工具，通过核心的Bean factory实现了底层的类的实例化和生命周期的管理。在整个框架中，各类型的功能被抽象成一个个的 Bean，这样就可以实现各种功能的管理，包括动态加载和切面编程。','N','','','','','',320,'2020-12-24','A'),
(35,'Android',20,'https://img2.baidu.com/it/u=2487951908,1203613635&fm=26&fmt=auto&gp=0.jpg','安卓是一种基于Linux内核（不包含GNU组件）的自由及开放源代码的操作系统。主要使用于移动设备，如智能手机和平板电脑，由美国Google公司和开放手机联盟领导及开发。Android操作系统最初由Andy Rubin开发，主要支持手机。','N','','','','','',353,'2021-01-01','C'),
(37,'Vue',0,'https://img1.baidu.com/it/u=3611752850,1977214230&fm=26&fmt=auto&gp=0.jpg','Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。','N','','','','','',353,'2021-01-01','B'),
(41,'操作系统',0,'https://img2.baidu.com/it/u=2367928498,1806339514&fm=26&fmt=auto&gp=0.jpg','操作系统（operation system，简称OS）是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。','N','','','','','',353,'2021-01-05','A'),
(42,'算法',20,'https://img2.baidu.com/it/u=272029358,3921751305&fm=26&fmt=auto&gp=0.jpg','算法是一系列解决问题的清晰指令，也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。算法工程师就是利用算法处理事物的人。','N','','','','','',353,'2021-01-05','B'),
(43,'数据库',0,'https://img2.baidu.com/it/u=618995187,3800041806&fm=26&fmt=auto&gp=0.jpg','数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。','N','','','','','',353,'2021-01-05','C'),
(44,'深度学习',45,'https://img0.baidu.com/it/u=111587484,1156745487&fm=26&fmt=auto&gp=0.jpg','深度学习是学习样本数据的内在规律和表示层次，这些学习过程中获得的信息对诸如文字，图像和声音等数据的解释有很大的帮助。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据。 深度学习是一个复杂的机器学习算法，在语音和图像识别方面取得的效果，远远超过先前相关技术。','N','','','','','',358,'2021-08-18','A'),
(45,'Python',0,'https://img2.baidu.com/it/u=4163938920,38528075&fm=26&fmt=auto&gp=0.jpg','Python提供了高效的高级数据结构，还能简单有效地面向对象编程。Python语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的编程语言。Python解释器易于扩展，可以使用C或C++（或者其他可以通过C调用的语言）扩展新的功能和数据类型。','N',NULL,NULL,NULL,NULL,NULL,356,'2021-06-16','A'),
(48,'区块链',42,'https://img2.baidu.com/it/u=2950461271,625742869&fm=11&fmt=auto&gp=0.jpg','区块链就是一个不断增长的全网总账本，每个完全节点都拥有完整的区块链，并且，节点总是信任最长的区块链，伪造区块链需要拥有超过51%的全网算力。区块链是由一个一个区块构成的有序链表，每一个区块都记录了一系列交易，并且，每个区块都指向前一个区块，从而形成一个链条。','Y',NULL,NULL,NULL,NULL,NULL,343,'2021-07-14','B');

/*Table structure for table `tb_comment` */

DROP TABLE IF EXISTS `tb_comment`;

CREATE TABLE `tb_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `author` varchar(100) DEFAULT NULL COMMENT '评论者',
  `email` varchar(100) DEFAULT NULL COMMENT '邮箱',
  `create_date` date DEFAULT NULL COMMENT '创建时间',
  `content` text DEFAULT NULL COMMENT '正文',
  `status` int(1) DEFAULT NULL COMMENT '0 待批准，1已通过2未通过',
  `article_id` int(11) DEFAULT NULL COMMENT '文章ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='评论';

/*Data for the table `tb_comment` */

insert  into `tb_comment`(`id`,`author`,`email`,`create_date`,`content`,`status`,`article_id`) values 
(38,'ab','6379@qq.com','2021-08-14','先点个赞',0,66);

/*Table structure for table `tb_friend_link` */

DROP TABLE IF EXISTS `tb_friend_link`;

CREATE TABLE `tb_friend_link` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `url` varchar(100) DEFAULT NULL COMMENT '链接URL',
  `title` varchar(100) DEFAULT NULL,
  `target` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='友情链接';

/*Data for the table `tb_friend_link` */

insert  into `tb_friend_link`(`id`,`url`,`title`,`target`) values 
(8,'https://www.csdn.net/','CSDN','_blank'),
(9,'https://www.cnblogs.com/','博客园','_blank'),
(10,'https://juejin.cn/','掘金','_blank'),
(11,'https://www.jianshu.com/','简书','_blank'),
(12,'https://stackoverflow.com/','栈溢出','_blank'),
(13,'https://www.aqniu.com/','安全牛','_blank'),
(14,'https://www.nowcoder.com/','牛客网','_blank'),
(15,'https://www.t00ls.net/','T00ls','_blank'),
(16,'https://www.freebuf.com/','FreeBuf','_blank'),
(17,'https://thehackernews.com/','安全客','_blank');

/*Table structure for table `tb_tag` */

DROP TABLE IF EXISTS `tb_tag`;

CREATE TABLE `tb_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC;

/*Data for the table `tb_tag` */

insert  into `tb_tag`(`id`,`tag_name`) values 
(5,'Java'),
(6,'Vue'),
(8,'神经网络'),
(9,'Go'),
(10,'渗透'),
(11,'SpringBoot'),
(12,'微服务'),
(13,'操作系统'),
(14,'其他'),
(15,'关系型数据库'),
(16,'数据结构'),
(17,'算法'),
(18,'非关系型数据库'),
(19,'网络协议'),
(20,'密码学'),
(21,'爬虫'),
(22,'并发编程'),
(23,'Unity3D'),
(25,'Python');

/*Table structure for table `tb_user` */

DROP TABLE IF EXISTS `tb_user`;

CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_name` varchar(100) DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) DEFAULT NULL COMMENT '密码',
  `nick_name` varchar(100) DEFAULT NULL COMMENT '名称',
  `email` varchar(100) DEFAULT NULL COMMENT '邮箱',
  `avatar` varchar(100) DEFAULT NULL COMMENT '头像',
  `create_date` date DEFAULT NULL COMMENT '创建时间',
  `status` char(1) DEFAULT NULL COMMENT 't代表正常，f代表禁用，d代表删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=359 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC;

/*Data for the table `tb_user` */

insert  into `tb_user`(`id`,`user_name`,`password`,`nick_name`,`email`,`avatar`,`create_date`,`status`) values 
(353,'admin','36d996aa','亚伯拉罕','fancypig@qq.com','http://8.135.100.252/image/2018-8-8/50dfa55a-4314-424f-81f2-a4ae90b20fff.jpg','2020-12-29','T'),
(354,'vuepress','gr64s321','尤雨溪','findshun@qq.com','http://8.135.100.252/image/2018-8-8/3776e5a9-45ee-4e54-81f3-8712f3e3b61a.jpg','2020-12-30','T'),
(356,'cunfu','114io860','诸葛亮','luxin046029@qq.com','http://8.135.100.252/image/2018-8-8/9c9fca68-859a-4f9b-a2df-bccf280ba62b.jpg','2021-01-01','T'),
(357,'joker','66co2008','Ledger','cdnsjk@qq.com','http://8.135.100.252/image/2018-8-8/dd214d55-e186-46ae-9301-ef19c7708170.jpg','2021-01-06','T'),
(358,'niki','88g6d507','白勇','arod167@cloud.com','http://8.135.100.252/image/2018-8-8/b8b3c645-1b21-4c1a-aed7-f2cb43e194ba.jpg','2021-08-18','T');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
